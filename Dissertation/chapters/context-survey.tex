With numerous examples of software-based critical faults, e.g. the malfunction of NASA's ``Demonstration of Autonomous Rendezvous Technology (DART)'' in 2005 \cite{nasa2006dart}, the erroneous administration of radiation doses at Panama's National Oncology Institute in 2001 \cite{borras2006overexposure}, or the infamous explosion of the Ariane 5 flight 501 in 1996 \cite{board1996ariane}, reasoning about and asserting extra-functional properties of software is an important problem where unforeseen circumstances or uncaught edge-cases can have disastrous consequences. Some work on modelling extra-functional properties of programs has already been done. Model-checking,  Domain Specific Languages (DSLs) using Haskell and \Idris, and also simulators are all examples of tools used to verify software.


\section{Haskell-based DSLs}
	Feldspar \cite{5558637} is a language for reasoning about digital signal processing (DSP) algorithms and is built on Haskell. Feldspar's main building blocks are \texttt{value}, \texttt{ifThenElse}, \texttt{while}, and \texttt{parallel} \cite{5558637}. These capture the building-blocks of simple C programs and introduces its own unique function \texttt{parallel} for describing parts of the program where each `sub-computation' can be done independently \cite{5558637}. Feldspar's aim is to help build sound DSP algorithms and then use the high-level description to generate fast, low-level C code \cite{5558637}.
    \\\par
	
	Hume \cite{10.1007/978-3-540-39815-8_3} is a different DSL which focuses on modelling embedded systems. In Hume, the programmer can reason about \texttt{box}es, \texttt{wire}s, \texttt{device}s, \texttt{datatype}s, \texttt{function}s, and \texttt{exception}s \cite{10.1007/978-3-540-39815-8_3}. Through these constructs, the programmer can model embedded systems as coarse- or fine-grained as they want, and Hume then estimates the stack, heap, and space/time requirements \cite{10.1007/978-3-540-39815-8_3}.


\section{Idris-based DSLs}
	Several \Idris-based DSLs exist and demonstrate the benefits of using \Idris for implementing the DSLs. State-aware Embedded DSLs (EDSLs) for systems programming \cite{10.1007/978-3-642-27694-1_18} allows the programmer to reason about network transfer or correct file-access. This lets them construct safe, low-level protocols in a higher-level language, and the type-checker can help them spot problems by construction \cite{10.1007/978-3-642-27694-1_18} rather than by trial-and-error.
	Another example uses \Idris for concurrent programming \cite{brady2010correct}. By representing the state of a concurrent program and the locking and unlocking operations as types, the resulting EDSL allows the programmer to reason about the thread-safety of their program when constructing it, rather than when testing it.
	DSLs can also be used to create correct-by-construction network protocols where the embedded types ensure that the protocol operates correctly as long as it type-checks \cite{5158855}.


\section{Non-DSL Approaches}
	Alternatively to DSLs, a simulator could be used to measure extra-functional properties. Simulators model the hardware, so virtual readings of time and energy can be taken when running the program. The benefit is that there is no need to have the actual hardware and, depending on the power of the simulator and computer being used to run it, many different types of hardware can be simulated.
    \\
    
    Another alternative could be to use a model-checker. Tools like UPPAAL \cite{Larsen1997} or PRISM \cite{10.1007/978-3-642-22110-1_47} verify and validate timing properties of programs given as Petri Nets or timed automata. These tools are more general and can be applied to various programs, not just those designed for embedded systems. This makes them very powerful, but also increases their complexity.
    
    The \textsc{[mc]square} model-checker/simulator hybrid is specifically aimed at C code for embedded systems \cite{Schlich2009}. It works similar to a simulator to construct its models, i.e. it compiles and analyses the assembler code, and from this checks that the program's functionality is correct.


\section{Limitations of the existing work}
	The Haskell-based DSLs do not have a built-in, straightforward way of producing proofs for the written programs. Although existing research has used Haskell in combination with proof-assistants \cite{10.1007/978-3-319-08434-3_9}, this focuses on mathematical theories and proofs rather than proofs for extra-functional properties of programs. Having proofs for these is useful, as it means the programmer has a formal validation of the properties rather than a measurement or probable guarantee.
    \\
    
    Simulation mainly focus on the designing the architectures themselves \cite{10.1007/3-540-46002-0_32,Lee:2008:FFC:1375657.1375670} or target the energy consumption of the entire embedded system \cite{782199} rather than a specific program or piece of the software and the readings gotten are based on a simulation, not the real hardware which could behave differently. Simulation is also orders of magnitude slower than running the actual hardware, even when sacrifices are made in terms of accuracy (for example, using a functional simulator instead of a cycle-accurate simulator).
    \\
    
    Model-checkers are slow due to the fact that they exhaustively explore the state-space of the given model/program. A well-known problem for model-checkers is the state-explosion problem \cite{Clarke2001,Clarke2012,Valmari1998}: Due to exhaustively searching the state-space, only small programs can be modelled as adding states exponentially grows the search space \cite{Clarke2001,Clarke2012}, leading to the model-checker needing more memory than the computer can provide. One workaround is to break the program up into smaller parts which can then be modelled. However, each of these smaller parts are then susceptible to another limiting factor of model-checkers: They require the programmers to manually model the software or part of program to analyse. Since this has to be done in the model-checking software, this often implies learning a new, likely unfamiliar, tool. As such, getting from the program to the model is slow and prone to human error, even more so when multiple models are required for parts of one program.
	
    
\section{Benefits of using \Idris}
	Using a strongly-typed language like \Idris which supports user-defined types and dependent types where the type depends on a value or property means that when we have modelled the problem as a collection of dependent types, we can guarantee the program works as intended through the type-checker. If our model of the problem is incorrect, the type-checker will prevent the model from even compiling. This lets us be very specific about which parts of our framework do what, and be certain that they \textit{do} do those things. Furthermore, the built-in proof system allows for conditions in the resulting models to be formally guaranteed to hold without having to bring in an external tool. We can design our framework around supporting provable properties. Existing research using \Idris \cite{5158855,brady2010correct,10.1007/978-3-642-27694-1_18} show that these features can be leveraged to create powerful prototyping and formal verification methods. However, the existing work is not in the area of time and energy guarantees.
