\begin{itemize}
    \item existing EDSLs focus on code generation or language reasoning, not the
          HW side
    %\item why Haskell and Idris are good tools for implementing EDSLs (citing
    %      \cite{10.1007/3-540-45350-4_5,685738,hudak1996building} for Haskell
    %	   and \cite{brady2015embedded} for Idris)
    %\item mention Hume \cite{10.1007/978-3-540-39815-8_3} and Feldspar
    %      \cite{5558637} as examples of existing EDSLs
	%\item something on how Idris proofs work (citing \cite{brady2015embedded})?
	%\item mention previous work done using Idris on concurrency
    %      \cite{brady2010correct}?
    %\item mention previous work done using Idris on systems programming
    %       \cite{10.1007/978-3-642-27694-1_18,Brady:2011:ISP:1929529.1929536}?
    %\item mention previous work done using Idris on network protocols
    %      \cite{5158855}?
    \item the existing Haskell-based DSLs do not have a built-in proof system(?)
          for guaranteeing that the ``type-promises'' are correct?
          %TODO: Haskell and proofs
    %\item outside DSL-scope, things like simulation (cycle-accurate, functional,
    %      etc.). But these are slow and/or resource-intensive
    %\item the existing Idris-based DSLs do not focus on generating
    %      proofs/contracts that the programs do what they say (beyond
    %      type-checking) and do not concern themselves with timing or energy
\end{itemize}

Some work on modelling extra-functional properties of programs has already been done. Models and DSLs have been made for various purposes using Haskell and \Idris, but also using simulators.

\section{Haskell-based DSLs}
	Feldspar \cite{5558637} is a language for reasoning about digital signal processing (DSP) algorithms and is built on Haskell. Its DSL's main building blocks are \texttt{value}, \texttt{ifThenElse}, \texttt{while}, and \texttt{parallel} \cite{5558637}. These capture the building-blocks of simple C programs and introduces its own unique function \texttt{parallel} for describing parts of the program where each `sub-computation' can be done independently \cite{5558637}. Feldspar's aim is to help build sound DSP algorithms and then use the high-level description to generate fast, low-level C code \cite{5558637}. \textbf{[What/How to elaborate?]}
    \\\par
	
	Hume \cite{10.1007/978-3-540-39815-8_3} is a different DSL which focuses on modelling embedded systems. In Hume, the programmer can reason about \texttt{box}es, \texttt{wire}s, \texttt{device}s, \texttt{datatype}s, \texttt{function}s, and \texttt{exception}s \cite{10.1007/978-3-540-39815-8_3}. Through these constructs, the programmer can model embedded systems as coarse- or fine-grained as they want, and Hume then estimates the stack, heap, and space/time requirements \cite{10.1007/978-3-540-39815-8_3}.
    
    \sout{The idea behind Hume is that the low-level requirements of the embedded system can guide the process of adapting an existing high(er)-level language to the embedded system, whilst maintaining resource requirements \cite{10.1007/978-3-540-39815-8_3}.}
    
    \textbf{[Correctly understood? What/How to elaborate?]}

\section{Idris-based DSLs}
	Several Idris-based DSLs exist and demonstrate the benefits of using \Idris for implementing the DSLs. State-aware EDSLs for systems programming \cite{10.1007/978-3-642-27694-1_18} allows the programmer to reason about network transfer or correct file-access. This lets them construct safe, low-level protocols in a higher-level language, and the type-checker can help them spot problems by construction \cite{10.1007/978-3-642-27694-1_18} rather than by trial-and-error.
	Another example uses Idris for concurrent programming \cite{brady2010correct}. By representing the state of a concurrent program and the locking and unlocking operations as types, the resulting EDSL allows the programmer to reason about the thread-safety of their program when constructing it, rather than when testing it.
	DSLs can also be used to create correct-by-construction network protocols where the embedded types ensure that the protocol operates correctly as long as it type-checks \cite{5158855}.

\section{Non-DSL Approaches}
	Alternatively to DSLs, a simulator could be used. Since simulators model the hardware itself, ``readings'' can be taken from running the program. With a simulator, there is no need to have the actual hardware and, depending on the power of the simulator and computer being used to run it, many different types of hardware can be simulated. However, simulators mainly focus on the designing the architectures themselves \cite{10.1007/3-540-46002-0_32,Lee:2008:FFC:1375657.1375670} or target the energy consumption of the entire embedded system \cite{782199} rather than a specific program or piece of software. Simulation is also orders of magnitude slower than running the actual hardware, even when sacrifices are made in terms of accuracy (for example, using a functional simulator instead of a cycle-accurate simulator).

\section{Limitations of the existing work}
	[The Haskell-based DSLs do not have a built-in, straightforward way of producing proofs for the written programs.]
	
	The utility of Idris-based DSLs is great: The types ensure that the program is correctly written, and the built-in proof system allows for conditions to be formally guaranteed to hold. Existing research using these properties \cite{5158855,brady2010correct,10.1007/978-3-642-27694-1_18} show that these features can be leveraged to create powerful prototyping and formal verification methods, but is not in the area of time and energy guarantees.
