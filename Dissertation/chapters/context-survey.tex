With numerous examples of software-based critical faults, e.g. the malfunction of NASA's ``Demonstration of Autonomous Rendezvous Technology (DART)'' in 2005 \cite{nasa2006dart}, the erroneous administration of radiation amounts at Panama's National Oncology Institute in 2001 \cite{borras2006overexposure}, or the infamous explosion of the Arian 5 flight 501 in 1996 \cite{board1996ariane}, reasoning about and asserting extra-functional properties of software is a very important problem. Some work on modelling extra-functional properties of programs has already been done. Model-checking,  DSLs using Haskell and \Idris, and also simulators are all examples of these.

\section{Haskell-based DSLs}
	Feldspar \cite{5558637} is a language for reasoning about digital signal processing (DSP) algorithms and is built on Haskell. Its DSL's main building blocks are \texttt{value}, \texttt{ifThenElse}, \texttt{while}, and \texttt{parallel} \cite{5558637}. These capture the building-blocks of simple C programs and introduces its own unique function \texttt{parallel} for describing parts of the program where each `sub-computation' can be done independently \cite{5558637}. Feldspar's aim is to help build sound DSP algorithms and then use the high-level description to generate fast, low-level C code \cite{5558637}. \textbf{[What/How to elaborate?]}
    \\\par
	
	Hume \cite{10.1007/978-3-540-39815-8_3} is a different DSL which focuses on modelling embedded systems. In Hume, the programmer can reason about \texttt{box}es, \texttt{wire}s, \texttt{device}s, \texttt{datatype}s, \texttt{function}s, and \texttt{exception}s \cite{10.1007/978-3-540-39815-8_3}. Through these constructs, the programmer can model embedded systems as coarse- or fine-grained as they want, and Hume then estimates the stack, heap, and space/time requirements \cite{10.1007/978-3-540-39815-8_3}.
    
    \sout{The idea behind Hume is that the low-level requirements of the embedded system can guide the process of adapting an existing high(er)-level language to the embedded system, whilst maintaining resource requirements \cite{10.1007/978-3-540-39815-8_3}.}
    
    \textbf{[Correctly understood? What/How to elaborate?]}

\section{Idris-based DSLs}
	Several Idris-based DSLs exist and demonstrate the benefits of using \Idris for implementing the DSLs. State-aware EDSLs for systems programming \cite{10.1007/978-3-642-27694-1_18} allows the programmer to reason about network transfer or correct file-access. This lets them construct safe, low-level protocols in a higher-level language, and the type-checker can help them spot problems by construction \cite{10.1007/978-3-642-27694-1_18} rather than by trial-and-error.
	Another example uses Idris for concurrent programming \cite{brady2010correct}. By representing the state of a concurrent program and the locking and unlocking operations as types, the resulting EDSL allows the programmer to reason about the thread-safety of their program when constructing it, rather than when testing it.
	DSLs can also be used to create correct-by-construction network protocols where the embedded types ensure that the protocol operates correctly as long as it type-checks \cite{5158855}.

\section{Non-DSL Approaches}
	Alternatively to DSLs, a simulator could be used. Since simulators model the hardware itself, ``readings'' can be taken from running the program. With a simulator, there is no need to have the actual hardware and, depending on the power of the simulator and computer being used to run it, many different types of hardware can be simulated. However, simulators mainly focus on the designing the architectures themselves \cite{10.1007/3-540-46002-0_32,Lee:2008:FFC:1375657.1375670} or target the energy consumption of the entire embedded system \cite{782199} rather than a specific program or piece of software. Simulation is also orders of magnitude slower than running the actual hardware, even when sacrifices are made in terms of accuracy (for example, using a functional simulator instead of a cycle-accurate simulator).

\section{Limitations of the existing work}
	[The Haskell-based DSLs do not have a built-in, straightforward way of producing proofs for the written programs.]
	
	The utility of Idris-based DSLs is great: The types ensure that the program is correctly written, and the built-in proof system allows for conditions to be formally guaranteed to hold. Existing research using these properties \cite{5158855,brady2010correct,10.1007/978-3-642-27694-1_18} show that these features can be leveraged to create powerful prototyping and formal verification methods, but is not in the area of time and energy guarantees.
    
    [ However, most of the existing methods are either slow or require a lot of work by the programmer, potentially to the point of having to learn a completely new language.]
