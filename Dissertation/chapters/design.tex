\begin{itemize}
	%\item mention/explain TEAMPLAY \texttt{blocks}, \texttt{blockenergy},
    %      \texttt{blocktime}, etc?
	%\item \sout{\texttt{Eq} was already implemented (using `native' things)}
    %      \texttt{NEq} was more complicated (different ways \texttt{Nat}s can be
    %	  not equal)
    %\item explain how only \texttt{LTE} is required for that selection of
    %	  operators?
    %   \item \textbf{explain the structure of operators and decidability rules}
    %\item \texttt{And} was already implemented with custom types, used this as
    %	  inspiration for implementation of \texttt{Or}
    \item explain how these `building blocks'/operators go together (similar to
    	  a stack-based language)?
\end{itemize}

The first section (\ref{des:tp-dsl}) focuses on describing existing work done by the \textsc{TeamPlay} project \cite{teamplay:d1.1}.


\section{The TeamPlay Project}\label{des:tp-dsl}
    \subsection{Assertions and Contracts}
        \todo{diagram}
        \todo{describe mkCertificate}
        When writing C programs for embedded systems, the programmer might want to capture extra-functional properties like the time taken or the energy consumed. Furthermore, the programmer may want to have provable guarantees that these properties of the program hold. This is done through contracts which can be proven using the \Idris proof system. The Contract Specification Language (CSL) defined by the \textsc{TeamPlay} project \cite{teamplay:d1.1} lets the programmer annotate existing C code to express properties like the worst time cost of a loop or function, using \texttt{\_\_teamplay\_worst\_time}, and assert these, using \texttt{\_\_teamplay\_assert}. This results in a program whose extra-functional properties can be certified to hold. Since the CSL functions adhere to the C99 function naming scheme, the programmer does not need to change tools, libraries, compiler, or learn a new language. Instead, the annotations seamlessly integrate with the existing code, without disturbing its operation in any way. Once the code has been annotated, it can then be passed through a C parser which extracts the annotations and constructs a model in an \Idris-based DSL. This DSL is in turn what allows the programmer to get a contract specifying which properties do or do not hold, through the \Idris proof system.
        \begin{table}
            \centering
            \begin{tabular}{c | c}
                \textbf{C operator} & \Idris-based \textbf{DSL equivalent}   \\
                \hline
                \texttt{==}         & \texttt{Eq}     \\
                \texttt{!=}         & \texttt{NEq}    \\
                \texttt{<=}         & \texttt{LTE}    \\
                \texttt{<}          & \texttt{LT}     \\
                \texttt{>=}         & \texttt{GTE}    \\
                \texttt{>}          & \texttt{GT}     \\
                \texttt{\&\&}       & \texttt{And}    \\
                \texttt{||}         & \texttt{Or}     \\
                \texttt{!}          & \texttt{Not}
            \end{tabular}
            \caption{C to DSL mappings}
        \end{table}
    
    \subsection{Numeric Operators and Numeric Expressions}
        The numeric operators all take two arguments, their evaluation, a proof concerning what the operator evaluates to, and returns a \texttt{BooleanExpression}.
        The operands are \texttt{NumericExpression}s. A \texttt{NumericExpression} is defined by the following grammar:
        \setlength{\grammarindent}{12em}
        \begin{grammar}
            <NumericExpression>
            ::=  ; a literal\\
                 `Lit' <digit>$^+$
            \alt ; a variable\\
                 `Var' <identifier>
            \alt ; a parenthesised expression\\
                 `NParen' <NumericExpression>
            \alt ; addition\\
                 `Plus' <NumericExpression> <NumericExpression>
            \alt ; subtraction\\
                 `Sub' <NumericExpression> <NumericExpression>
            \alt ; multiplication\\
                 `Mul' <NumericExpression> <NumericExpression>
            \alt ; division\\
                 `Div' <NumericExpression> <NumericExpression>
            \alt ; modulo\\
                 `Mod' <NumericExpression> <NumericExpression>
        \end{grammar}
        \texttt{NumericExpression}s are evaluated given an environment \texttt{Env}. The environment is essentially a mapping from symbols to values.
        \begin{code}[caption={The type of the \texttt{eval} function}]
            eval : Env -> NumericExpression -> Nat
        \end{code}
        The \texttt{eval} function uses this to evaluate a \texttt{NumericExpression}: Given an \texttt{Env} and a \texttt{NumericExpression}, the \texttt{eval} function returns a natural number. This is the result of that \texttt{NumericExpression} over that environment. To use the evaluation in a proof, we use the \texttt{Evald} type.
        \begin{code}[caption={\texttt{Evald} as defined in the \Idris model},label={des:evald}]
    data Evald : NumericExpression -> Nat -> Type where
        MkEvald : (x : NumericExpression) -> (y : Nat) -> Evald x y
        \end{code}
        Listing \ref{des:evald} shows that \texttt{Evald} is a data type constructed from a \texttt{NumericExpression} and \texttt{Nat}. This  is because \texttt{eval} only evaluates the expression, it does not provide a proof linking the evaluated value and the original expression. The \texttt{Evald} type `links' the numeric expression (\texttt{x}) and its evaluation (\texttt{y}), proving that \texttt{x} evaluates to \texttt{y}.
        \\
        
        When applying a numeric operator to some \texttt{NumericExpression}s, we get a \texttt{BooleanExpression}.
    
    \subsection{Boolean Operators and Boolean Expressions}
        Boolean expressions result from either a numeric operator or a boolean operator. The grammar for constructing boolean expressions is:
        \setlength{\grammarindent}{11em}
        \begin{grammar}
            <BooleanExpression>
            ::=  ; a paranthesised expression\\
            `BParen' <BooleanExpression>
            \alt ; the negation of an expression\\
            `Not' <BooleanExpression>
            \alt ; the conjunction of two expressions\\
            `And' <BooleanExpression> <BooleanExpression>
            \alt ; the disjunction of two expressions\\
            `Or' <BooleanExpression> <BooleanExpression>
            \alt ; testing two numbers for equality\\
            `Eq' <NumericExpression> <NumericExpression>
            \alt ; testing two numbers for inequality\\
            `NEq' <NumericExpression> <NumericExpression>
            \alt ; whether one number is strictly less than the other\\
            `LT' <NumericExpression> <NumericExpression>
            \alt ; whether one number is less than or equal to the other\\
            `LTE' <NumericExpression> <NumericExpression>
            \alt ; whether one number is strictly greater than the other\\
            `GT' <NumericExpression> <NumericExpression>
            \alt ; whether one number is greater than or equal to the other\\
            `GTE' <NumericExpression> <NumericExpression>
        \end{grammar}
        Similar to \texttt{NumericExpressions}, \texttt{BooleanExpressions} are evaluated over an environment.
        \begin{code}[caption={The type of the \texttt{beval} function}]
            beval : Env -> BooleanExpression -> Bool
        \end{code}
        Given an \texttt{Env} and a \texttt{BooleanExpression}, the \texttt{beval} function returns a boolean. This boolean is the result of evaluating that \texttt{BooleanExpression} over that environment. Like with \texttt{NumericExpressions}, to use the evaluation in a proof, we have the \texttt{BEvald} type.
        \begin{code}[caption={\texttt{BEvald} as defined in the \Idris model}]
data BEvald : BooleanExpression -> Nat -> Type where
    MkBEvald : (x : BooleanExpression) -> (y : Bool) -> BEvald x y
        \end{code}
        \texttt{BEvald} works like \texttt{Evald} except for boolean expressions and values. It is a data type constructed from a \texttt{BooleanExpression} and a \texttt{Bool}. Like \texttt{eval}, the \texttt{beval} function only evaluates the value of the boolean expression, it does not provide a proof that the expression evaluates to that boolean. The \texttt{BEval} type is a proof that the boolean expression \texttt{x} evaluates to the boolean \texttt{y}.
        \\
        
        The operators \texttt{And}, \texttt{Eq}, \texttt{LT}, \texttt{LTE}, \texttt{GT}, and \texttt{GTE} were already implemented. So in order to have a complete set of operators, I implemented \texttt{NEq}, \texttt{Or}, and \texttt{Not}.


\section{Inequality (\texttt{NEq})}
    \texttt{Eq} had already been implemented by the \textsc{TeamPlay} project, using the built-in \texttt{(=)} data type and the \texttt{DecEq} interface, as part of the D1.1 deliverable \cite{teamplay:d1.1}. Because there is no built-in \texttt{NEq} data type, one had to be defined.
    \begin{code}[caption={The data type used for capturing inequality}]
        data TyNEq : Nat -> Nat -> Type where
            MkNEqL   : TyNEq Z (S k)
            MkNEqR   : TyNEq (S k) Z
            MkNEqRec : TyNEq k j -> TyNEq (S k) (S j)
    \end{code}
    The constructors for the \texttt{TyNEq} data type describe the different ways numbers can be not equal:
    \begin{itemize}
        \item \textbf{The first number is zero and the second is not} -- in this case the numbers are not equal, specifically the left number is zero. Since no number can have zero as its successor, the numbers are not equal.
        \item \textbf{The second number is zero and the first is not} -- in this case, the numbers are not equal, specifically the right number is zero. Since no number can have zero as its successor, the numbers are not equal.
        \item \textbf{The numbers are not equal} -- in this case, the successors of the numbers must also be not equal. For example, $2 \neq 5 \rightarrow 3 \neq 6 \rightarrow 4 \neq 7$ etc.
    \end{itemize}
    Using the \texttt{TyNEq} data type, we can then define \texttt{NEq}.
    \begin{code}[label={des:neq-code}, caption={The definition of \texttt{NEq}}, escapeinside={(*}{*)}]
        data BooleanExprssion : Type where
            (*\vdots*)
            
            NEq :  (x : NumericExpression)
                -> (y : NumericExpression)
                -> Evald x x'
                -> Evald y y'
                -> Dec (TyNEq x' y')
                -> BooleanExpression
            (*\vdots*)
    \end{code}
    
    \texttt{NEq} takes two numeric expressions, proofs of what they evaluate to, and a decidable proof of whether the numeric expressions are inequal. From this, \texttt{NEq} returns a \texttt{BooleanExpression} which will evaluate to \texttt{True} if the numeric expressions were not equal, and \texttt{False} otherwise. For the decidability part, we need some proof functions so that we can guarantee the inequality of numbers.
    
    \begin{code}[label={des:neq-uninh}, caption={Not equals cannot be constructed on 0 0}]
        implementation Uninhabited (TyNEq Z Z) where
            uninhabited MkNEqL   impossible
            uninhabited MkNEqR   impossible
            uninhabited MkNEqRec impossible
    \end{code}

    If we try to construct a \texttt{TyNEq} from 0 0, i.e. try to prove $0 \neq 0$, this is impossible: \texttt{MkNEqL} requires only the left argument to be zero, \texttt{MkNEqR} requires only the right argument to be zero, and \texttt{MkNEqRec} requires the successors to be not equal (i.e. $1 \neq 1$, $2 \neq 2$, etc.). So \texttt{TyNEq 0 0} is uninhabited as we cannot use any of its constructors to create that type. For non-zero equal numbers, we need to take a similar approach to \texttt{MkNEqRec}.
    
    \begin{code}[caption={Proving inequality of numbers is impossible}]
        succNEqImpossible : (contra : TyNEq k j -> Void) ->
                            TyNEq (S k) (S j) -> Void   
        succNEqImpossible contra (MkNEqRec x) = contra x
    \end{code}

    The \texttt{succNEqImpossible} function takes a proof that \texttt{TyNEq k j} cannot be constructed and proves that in that case, \texttt{TyNEq (S k) (S j)} can also not be constructed. What this does is maintain that if two numbers are \textit{not} not equal, i.e. that they \textit{are} equal, then so are their successors.\\
    With constructors for the valid \texttt{TyNEq} cases, and proofs why the invalid cases are impossible, we can construct the decidability rules for \texttt{TyNEq}. These will allow us to construct the \texttt{Dec (TyNEq x' y')} part from Listing \ref{des:neq-code}.
    
    \begin{code}[caption={Decidability rules for \texttt{NEq}}]
isNEq : (n1 : Nat) -> (n2 : Nat) -> Dec (TyNEq n1 n2)
isNEq Z Z         = No absurd
isNEq Z (S k)     = Yes MkNEqL
isNEq (S k) Z     = Yes MkNEqR
isNEq (S k) (S j) = case isNEq k j of
                        Yes prf   => Yes (MkNEqRec prf)
                        No contra => No (succNEqImpossible contra)
    \end{code}
    
    If the \texttt{isNEq} is given two zeros as its arguments, then it is absurd to construct an inequality (as described in Listing \ref{des:neq-uninh}). If either the first or second argument is zero and the other is not, then the inequality is trivial as no natural number can have \texttt{Z} as its successor. In the final case, where both numbers are non-zero, we recurse on their predecessors. If the predecessors are not equal (by one of them being zero and the other not), then the numbers themselves must also be not equal. On the other hand, if it was impossible to prove the predecessors unequal, we use \texttt{succNEqImpossible} to maintain/prove that it is also impossible for the successors to be unequal.
    \\\par
    
    With the \texttt{eval} function and the \texttt{Evald} type giving us the numbers, and the decidability rules through the implementation of the \texttt{Uninhabited} interface and using the \texttt{succNEqImpossible} function, we have all the parts needed for the \texttt{NEq} constructor. Hence, we can prove inequality between numbers.
    
    \begin{code}[caption={Evaluating \texttt{NEq} over an environment}, escapeinside={(*}{*)}]
        beval : (env : Env) -> (b : BooleanExpression) -> Bool
        (*\vdots*)
        beval env (NEq x y x' y' (Yes prf))   = True
        beval env (NEq x y x' y' (No contra)) = False
        (*\vdots*)
    \end{code}

    Given an environment and an inequality which has been proven to hold, the inequality evaluates to \texttt{True}. On the other hand, if the inequality has been proven impossible to hold, then it evaluates to \texttt{False}.
    
    
\section{Boolean Disjunction (\texttt{Or})}
    The boolean operators are made up of different stages: Constructors for boolean expressions which evaluate to true, the operators keywords, an evaluation of the boolean expression, and a proof of what the boolean expression evaluates to. Boolean conjunction (\texttt{And}) was already implemented. I used it as a starting point for how to implement \texttt{Or}, as they are somewhat similar.
    
    \begin{code}[label={des:tyand-or}, caption={The constructors for true \texttt{And} and \texttt{Or} statements}, escapeinside={(*}{*)}]
        mutual
            data TyAnd : Bool -> Bool -> Type where
                MkAnd  : TyAnd True True
            
            data TyOr : Bool -> Bool -> Type where
                MkOr  : TyOr True True
                MkOrL : TyOr True False
                MkOrR : TyOr False True
    \end{code}

    There is only one case where \texttt{And} evaluates to true, i.e. \texttt{And True True}. This is reflected in that the only constructor for \texttt{TyAnd} has to have both arguments be \texttt{True}. With this idea in mind, the constructors for \texttt{Or} can be implemented. \texttt{TyOr} can be constructed when the expression evaluates to true, i.e. in three cases:
    \begin{itemize}
        \item both arguments are \texttt{True}, \texttt{Or True True}
        \item the left argument is \texttt{True}, \texttt{Or True False}
        \item the right argument is \texttt{True}, \texttt{Or False True}
    \end{itemize}
    
    With constructors for \texttt{TyOr}, we can then define the \texttt{Or} operator similar to the \texttt{And} operator.
    
    \begin{code}[caption={The definitions of \texttt{And} and \texttt{Or}}, escapeinside={(*}{*)}]
            data BooleanExpression : Type where
                (*\vdots*)
                
                And :  (x : BooleanExpression)
                    -> (y : BooleanExpression)
                    -> BEvald x x'
                    -> BEvald y y'
                    -> Dec (TyAnd x' y')
                    -> BooleanExpression
                
                Or  :  (x : BooleanExpression)
                    -> (y : BooleanExpression)
                    -> BEvald x x'
                    -> BEvald y y'
                    -> Dec (TyOr x' y')
                    -> BooleanExpression
                (*\vdots*)
    \end{code}

    \texttt{And} takes 5 arguments: two boolean expressions, the proofs of what these evaluated to, and decidable proof of whether those arguments would cause the \texttt{And} to evaluate to true. From the constructors of \texttt{TyAnd} (Listing \ref{des:tyand-or}), this can only be constructed when both arguments are \texttt{True}, i.e. when the \texttt{And} would evaluate to \texttt{True}. Based on this, \texttt{And} returns a new \texttt{BooleanExpression} (which can then be evaluated using the \texttt{beval} function). \texttt{Or} takes the same first 4 arguments. The difference being that its 5$^{th}$ argument is a decidable proof of whether those arguments would cause the \texttt{Or} to evaluate to \texttt{True}. From the constructors of \texttt{TyOr} (Listing \ref{des:tyand-or}), this can only be constructed if one or both of the arguments is \texttt{True}, i.e. the \texttt{Or} would evaluate to \texttt{True}. Based on its arguments, \texttt{Or} then returns a new \texttt{BooleanExpression} (which can then be evaluated using the \texttt{beval} function). Both \texttt{And} and \texttt{Or} rely on \texttt{Dec}, i.e. that a proof that it cannot evaluate to \texttt{True} exists.
    
    \begin{code}[caption={Impossible \texttt{And} cases}]
        implementation Uninhabited (TyAnd False True) where
            uninhabited MkAnd impossible
            
        implementation Uninhabited (TyAnd True False) where
            uninhabited MkAnd impossible
            
        implementation Uninhabited (TyAnd False False) where
            uninhabited MkAnd impossible
    \end{code}

    Since \texttt{MkAnd} requires both arguments to be \texttt{True}, an implementation of \texttt{Uninhabited} can be given for the other three cases. In each of the cases, the \texttt{And} would evaluate to \texttt{False}. With an implementation of \texttt{Uninhabited}, we can provide a proof for each case that it is impossible to construct a \texttt{MkAnd} and as such, the expression must evaluate to \texttt{False}. For \texttt{Or} there is only one case which evaluates to \texttt{False}.
    
    \begin{code}[label={des:or-uninh}, caption={The impossible \texttt{Or} case}]
        implementation Uninhabited (TyOr False False) where
            uninhabited MkOr  impossible
            uninhabited MkOrL impossible
            uninhabited MkOrR impossible
    \end{code}

    \texttt{MkOr} requires at least one of the arguments to be \texttt{True} (see Listing \ref{des:tyand-or}). As such, the case where we would have a \texttt{TyOr False False} is impossible. None of the constructors provided for \texttt{TyOr} can be used on \texttt{False False}, so a \texttt{TyOr} cannot be created. This means the \texttt{Or} cannot evaluate to \texttt{True}, i.e. we have a proof that it must evaluate to \texttt{False}. Using these proofs of when a \texttt{TyOr} can be constructed, we can define the decidability rules for \texttt{Or}.
    
    \begin{code}[caption={Decidability rules for \texttt{Or}}]
        isOr : (b1 : Bool) -> (b2 : Bool) -> Dec (TyOr b1 b2)
        isOr False False = No absurd
        isOr True False  = Yes MkOrL
        isOr False True  = Yes MkOrR
        isOr True True   = Yes MkOr
    \end{code}
    
    When at least one of the arguments to \texttt{isOr} is \texttt{True}, it is possible to construct a \texttt{TyOr} using the appropriate constructor. If both arguments are \texttt{False}, constructing a \texttt{TyOr} is absurd since none of the constructors can be applied to \texttt{False False} (as defined in Listing \ref{des:or-uninh}). Hence, given two boolean expressions, a proof of what they evaluate to, and using the decidability rules, we can construct a \texttt{BooleanExpression} using the \texttt{Or} constructor, i.e. we can prove boolean disjunction.
    
    \begin{code}[caption={Evaluating \texttt{Or} over an environment}, escapeinside={(*}{*)}]
        beval : (env : Env) -> (b : BooleanExpression) -> Bool
        (*\vdots*)
        beval env (Or x y x' y' (Yes prf))    = True
        beval env (Or x y x' y' (No contra))) = False
        (*\vdots*)
    \end{code}

    The evaluation of a disjunction over an environment is \texttt{True} given a disjunction which has been proven to hold, and \texttt{False} given a disjunction which has been proven to be impossible to hold.


\section{Boolean Negation (\texttt{Not})}
    Boolean negation was fairly simple to implement. As with the other operators, I initially declared a custom data type to capture what negations are valid.
    
    \begin{code}[caption={The case where \texttt{Not} would evaluate to \texttt{True}}]
            data TyBNot : Bool -> Type where
                MkBNot  : TyBNot False
    \end{code}
    
    The only case where boolean negation evaluates to \texttt{True} is when negating \texttt{False}. Therefore, it is only possible to construct a \texttt{TyBNot} if the given \texttt{BooleanExpression} was \texttt{False}.
    Similarly, there is only one case where boolean negation evaluates to \texttt{False}.
    
    \begin{code}[caption={The \texttt{uninhabited} case for constructing a \texttt{TyBNot}}]
        implementation Uninhabited (TyBNot True) where
            uninhabited MkBNot impossible
    \end{code}
    
    The \texttt{MkBNot} constructor only works if the argument is \texttt{False}, so constructing a \texttt{TyBNot} given \texttt{True} is impossible.
    
    \begin{code}[caption={Decidability rules for \texttt{Not}}]
        isNot : (b : Bool) -> Dec (TyBNot b)
        isNot False = Yes MkBNot
        isNot True  = No absurd
    \end{code}
    
    If the argument is \texttt{False}, the negation is \texttt{True}, so a \texttt{TyBNot} is constructed. Otherwise, if the argument is \texttt{True}, then it is absurd to construct a \texttt{TyBNot} as the negation will evaluate to \texttt{False}. This, combined with the given boolean expression and a proof of what it evaluates to, allows us to prove boolean negation.

    \begin{code}[caption={\texttt{beval} for \texttt{Not}}, escapeinside={(*}{*)}]
        beval : (env : Env) -> (b : BooleanExpression) -> Bool
            (*\vdots*)
        beval env (Not x x' (Yes prf))   = True
        beval env (Not x x' (No contra)) = False
            (*\vdots*)
    \end{code}
    
    Since we can prove negation, we can also evaluate it. Given an environment \texttt{Env} and a \texttt{Not}-expression which has been proven to hold true, its evaluation is the boolean `\texttt{True}'. Otherwise, if it has been proven to be impossible to hold, then its evaluation is the boolean `\texttt{False}'.
