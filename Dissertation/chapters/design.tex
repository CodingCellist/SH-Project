\begin{itemize}
	\item mention/explain TEAMPLAY \texttt{blocks}, \texttt{blockenergy},
          \texttt{blocktime}, etc?
    % TODO: CSL
	\item \sout{\texttt{Eq} was already implemented (using `native' things)}
    %      \texttt{NEq} was more complicated (different ways \texttt{Nat}s can be
    %	  not equal)
    %\item explain how only \texttt{LTE} is required for that selection of
    %	  operators?
    %   \item \textbf{explain the structure of operators and decidability rules}
    %\item \texttt{And} was already implemented with custom types, used this as
    %	  inspiration for implementation of \texttt{Or}
    \item explain how these `building blocks'/operators go together (similar to
    	  a stack-based language)?
\end{itemize}

When writing C programs for embedded systems, the programmer might want to capture extra-functional properties like the time taken or the energy consumed. Furthermore, the programmer may want to have provable guarantees that these properties of the program hold. This is done through contracts which can be proven using the \Idris proof system. The Contract Specification Language (CSL) works by declaring C variables, and then using these in the \Idris-based EDSL. By using an EDSL, the programmer does not need to change tools/libraries or learn a new language. Instead, the annotations seamlessly integrate with the existing code. When compiling the CSL, the variables are translated to \texttt{Var} types, numbers are translated to \texttt{Lit} types, all of which can then be evaluated using the given \texttt{Env}.
\\\par

The following section (\ref{des:tp-dsl}) focuses on describing existing work done by the \textsc{TeamPlay} project \cite{teamplay:d1.1}.

\section{The TeamPlay DSL}\label{des:tp-dsl}
    \subsection{C to DSL mappings}
        \begin{tabular}{c | c}
            \textbf{C operator} &   \textsc{TeamPlay} \textbf{DSL equivalent}   \\
            \hline
            \texttt{==}         &   \texttt{Eq}     \\
            \texttt{!=}         &   \texttt{NEq}    \\
            \texttt{<=}         &   \texttt{LTE}    \\
            \texttt{<}          &   \texttt{LT}     \\
            \texttt{>=}         &   \texttt{GTE}    \\
            \texttt{>}          &   \texttt{GT}     \\
            \texttt{\&\&}       &   \texttt{And}    \\
            \texttt{||}         &   \texttt{Or}     \\
            \texttt{!}          &   \texttt{Not}
        \end{tabular}
    
    \subsection{Numeric Operators and Numeric Expressions}
        The numeric operators all take two arguments, their evaluation, a proof concerning what the operator evaluates to, and returns a \texttt{BooleanExpression}.
        The operands are \texttt{NumericExpression}s. A \texttt{NumericExpression} is defined by the following grammar:
        \setlength{\grammarindent}{12em}
        \begin{grammar}
            <NumericExpression>
            ::=  ; a literal\\
                 `Lit' <digit>$^+$
            \alt ; a variable\\
                 `Var' <identifier>
            \alt ; a parenthesised expression\\
                 `NParen' <NumericExpression>
            \alt ; addition\\
                 `Plus' <NumericExpression> <NumericExpression>
            \alt ; subtraction\\
                 `Sub' <NumericExpression> <NumericExpression>
            \alt ; multiplication\\
                 `Mul' <NumericExpression> <NumericExpression>
            \alt ; division\\
                 `Div' <NumericExpression> <NumericExpression>
            \alt ; modulo\\
                 `Mod' <NumericExpression> <NumericExpression>
        \end{grammar}
        \texttt{NumericExpression}s are evaluated given an environment \texttt{Env}. The environment is essentially a mapping from symbols to values.
        \begin{code}[caption={The type of the \texttt{eval} function}]
            eval : Env -> NumericExpression -> Nat
        \end{code}
        The \texttt{eval} function uses this to evaluate a \texttt{NumericExpression}: Given an \texttt{Env} and a \texttt{NumericExpression}, the \texttt{eval} function returns a natural number. This is the result of that \texttt{NumericExpression} over that environment. To use the evaluation in a proof, we use the \texttt{Evald} type.
        \begin{code}[caption={\texttt{Evald} as defined in the \textsc{TeamPlay} CSL},label={des:evald}]
    data Evald : NumericExpression -> Nat -> Type where
        MkEvald : (x : NumericExpression) -> (y : Nat) -> Evald x y
        \end{code}
        Listing \ref{des:evald} shows that \texttt{Evald} is a data type constructed from a \texttt{NumericExpression} and \texttt{Nat}. This  is because \texttt{eval} only evaluates the expression, it does not provide a proof linking the evaluated value and the original expression. The \texttt{Evald} type `links' the numeric expression (\texttt{x}) and its evaluation (\texttt{y}), proving that \texttt{x} evaluates to \texttt{y}.
        \\
        
        When applying a numeric operator to some \texttt{NumericExpression}s, we get a \texttt{BooleanExpression}.
    
    \subsection{Boolean Operators and Boolean Expressions}
        \begin{code}[caption={The definitions of \texttt{And} and \texttt{Or}},escapeinside={(*}{*)}]
        mutual
            data TyAnd : Bool -> Bool -> Type where
                MkAnd  : TyAnd True True
                
            data TyOr : Bool -> Bool -> Type where
                MkOr  : TyOr True True
                MkOrL : TyOr True False
                MkOrR : TyOr False True
                
            data BooleanExpression : Type where
                (*\vdots*)
                And  : (x : BooleanExpression)
                    -> (y : BooleanExpression)
                    -> BEvald x x'
                    -> BEvald y y'
                    -> Dec (TyAnd x' y')
                    -> BooleanExpression
                    
                Or   : (x : BooleanExpression)
                    -> (y : BooleanExpression)
                    -> BEvald x x'
                    -> BEvald y y'
                    -> Dec (TyOr x' y')
                    -> BooleanExpression
                (*\vdots*)
        \end{code}
        % TODO: Explain `And` and `Or` based on the code above
        The boolean operators \texttt{And} and \texttt{Or} take two arguments, their evaluation, a proof of what the operator evaluates to, and returns a \texttt{BooleanExpression}. The boolean \texttt{Not} operator only takes one operand, its evaluation, a proof of what the operator evaluates to, and returns a \texttt{BooleanExpression}. As we are dealing with boolean operators, the operand(s) are \texttt{BooleanExpression}(s) as well.
        As with the numeric operators and the \texttt{NumericExpression}s, \texttt{BooleanExpression}s are evaluated over an environment. This is the purpose of the \texttt{beval} function.
        \begin{code}[caption={The type of the \texttt{beval} function}]
            beval : Env -> BooleanExpression -> Bool
        \end{code}
        The \texttt{beval} function takes an environment and a \texttt{BooleanExpression} and returns the evaluation of the \texttt{BooleanExpression} over that environment. To use the boolean evaluation in a proof, we have the type \texttt{BEvald}.
        \begin{code}[caption={The \texttt{BEvald} data type}]
        data BEvald : BooleanExpression -> Bool -> Type where
            MkBEvald : (x : BooleanExpression) ->
                        (y : Bool) -> BEvald x y
        \end{code}
        % TODO: explain BEvald
        Similar to \texttt{Evald}, captures the \texttt{BooleanExpression} and the \texttt{Bool} it evaluated to.
        \\\par
        
        The operators \texttt{And}, \texttt{Eq}, \texttt{LT}, \texttt{LTE}, \texttt{GT}, and \texttt{GTE} were already implemented. So in order to have a complete set, I implemented \texttt{NEq}, \texttt{Or}, and \texttt{Not}.

\section{Inequality (\texttt{NEq})}
    % TODO: Rewrite this bit
    \texttt{Eq} had already been implemented by the \textsc{TeamPlay} project as part of the D1.1 deliverable \cite{teamplay:d1.1}. However, \texttt{NEq} had not and was more complicated due to the fact that natural numbers can be different in infinitely many ways. For example, 1 is not equal to 2 because 1 is 1 smaller than 2, but 1 is also not equal to 3 in a different way than it is not equal to 2 (and etc. for all combinations of inequal natural numbers). I implemented \texttt{NEq} by doing the `opposite' of \texttt{decEq} (Listing \ref{lst:decEq}). There are three cases under which natural numbers can be not equal, two base-cases and one general case. The cases are the constructors for the \texttt{TyNEq} type:
    \begin{code}[caption={\texttt{TyNEq}} -- proving inequality.]
        data TyNEq : Nat -> Nat -> Type where
        MkNEqL   : TyNEq Z (S k)
        MkNEqR   : TyNEq (S k) Z
        MkNEqRec : TyNEq k j -> TyNEq (S k) (S j)
    \end{code}
    \begin{enumerate}
        \item \textbf{The first number is zero and the second is not} -- in this case the numbers are not equal, specifically the left number is zero. Since no number can have zero as its successor, the numbers are not equal.
        \item \textbf{The second number is zero and the first is not} -- in this case, the numbers are not equal, specifically the right number is zero. Since no number can have zero as its successor, the numbers are not equal.
        \item \textbf{The numbers are not equal} -- in this case, the successors of the numbers must also be not equal.
    \end{enumerate}
    This guarantees that a \texttt{TyNEq} can only be constructed if the numbers are truly not equal and hence allows for the definition of decidability rules for inequality.
    \begin{code}[caption={Decidability rules for inequality}]
    -- if both numbers are zero, we cannot construct a TyNEq as
    -- its constructors require one of the numbers to be non-zero
    implementation Uninhabited (TyNEq Z Z) where
        uninhabited MkNEqL impossible
        uninhabited MkNEqR impossible

    -- if the numbers are equal, we cannot construct a TyNEq for      
    -- the successors as neither successor can be zero
    proveSuccEq : TyNEq (S k) (S j) -> Void
    proveSuccEq MkNEqL impossible
    proveSuccEq MkNEqR impossible
    
    -- if we have a recursive counter-proof for k and j, the
    -- counter-proof for their successors is 'included'
    proveNEqRec : (contra : TyNEq k j -> Void) ->
                  TyNEq (S k) (S j) -> Void
    proveNEqRec contra (MkNEqRec x) = contra x
    
    -- decidability rules for "NEq"
    isNEq : (n1 : Nat) -> (n2 : Nat) -> Dec (TyNEq n1 n2)
    isNEq Z Z         = No absurd
    isNEq Z (S k)     = Yes MkNEqL
    isNEq (S k) Z     = Yes MkNEqR
    isNEq (S k) (S j) = case isNEq k j of
                            Yes prf => Yes (MkNEqRec prf)
                            No contra => No (proveNEqRec contra)
    \end{code}
    
    With decidability rules for \texttt{NEq}, inequality could now be proven (see Section \ref{evaln:ops:neq})
    
\section{Boolean Disjunction (\texttt{Or})}
    Boolean conjunction (\texttt{And}) was already implemented. I used it as a starting point for how to implement \texttt{Or}, as they are somewhat similar.
    \begin{code}[caption={The proof type for \texttt{And}}]
        data TyAnd : Bool -> Bool -> Type where
            MkAnd : TyAnd True True
    \end{code}
    The proof of the conjunction of two \texttt{BooleanExpression}s being true was done through the use of the \texttt{TyAnd} type, who's only constructor was one where both expressions were true. Seeing this, I defined the \texttt{TyOr} type, which could only be constructed if the disjunction of the expressions was true:
    \begin{code}[caption={The proof type for \texttt{Or}}]
        data TyOr : Bool -> Bool -> Type where
            MkOr  : TyOr True True
            MkOrL : TyOr True False
            MkOrR : TyOr False True
    \end{code}
    Then, an implementation of the \texttt{Uninhabited} interface was done for the case where the disjunction would evaluate to false:
    \begin{code}[caption={\texttt{Or False False} is impossible}]
        implementation Uninhabite (TyOr False False) where
            uninhabited MkOr  impossible
            uninhabited MkOrL impossible
            uninhabited MkOrR impossible
    \end{code}
    With the proofs and counter-proofs implemented, the decidability rules for \texttt{Or} were implemented:
    \begin{code}[caption={Decidability rules for \texttt{Or}}]
        isOr : (b1 : Bool) -> (b2 : Bool) -> Dec (TyOr b1 b2)
        isOr False False = No absurd
        isOr True False  = Yes MkOrL
        isOr False True  = Yes MkOrR
        isOr True True   = Yes MkOr
    \end{code}
    Finally, \texttt{beval} was extended to also handle \texttt{Or}:
    \begin{code}[caption={\texttt{beval} for \texttt{Or}}, escapeinside={(*}{*)}]
        beval : (env : Env) -> (b : BooleanExpression) -> Bool
            (*\vdots*)
        beval env (Or x y x' y' (Yes prf))   = True
        beval env (Or x y x' y' (No contra)) = False
            (*\vdots*)
    \end{code}
    
    An evaluation showing that these do indeed prove \texttt{Or} can be found in Section \ref{evaln:ops:or}.

\section{Boolean Negation (\texttt{Not})}
    Boolean negation was also implemented using a custom proof type. The only case where negation evaluates to true is when negating false. Therefore, it is only possible to construct a \texttt{TyBNot} if the given \texttt{BooleanExpression} was false:
    \begin{code}[caption={The proof type for \texttt{Not}}]
        data TyBNot : Bool -> Type where
            MkBNot  : TyBNot False
    \end{code}
    This time, only a single counter-proof is needed, i.e. \texttt{Not True}:
    \begin{code}[caption={Constructing \texttt{Not True} is impossible}]
        implementation Uninhabited (TyBNot True) where
            uninhabited MkBNot impossible
    \end{code}
    From this, the decidability rules are trivial:
    \begin{code}[caption={Decidability rules for \texttt{Not}}]
        isNot : (b : Bool) -> Dec (TyBNot b)
        isNot False = Yes MkBNot
        isNot True  = No absurd
    \end{code}
    As before, \texttt{beval} was extended to also be able to evaluate \texttt{Not}:
    \begin{code}[caption={\texttt{beval} for \texttt{Not}}, escapeinside={(*}{*)}]
        beval : (env : Env) -> (b : BooleanExpression) -> Bool
            (*\vdots*)
        beval env (Not x x' (Yes prf))   = True
        beval env (Not x x' (No contra)) = False
            (*\vdots*)
    \end{code}
    
    An evaluation of \texttt{Not} can be found in Section \ref{evaln:ops:not}.
    
    
