\begin{itemize}
	\item mention/explain TEAMPLAY \texttt{blocks}, \texttt{blockenergy},
          \texttt{blocktime}, etc?
    % TODO: CSL
	\item \sout{\texttt{Eq} was already implemented (using `native' things)}
    %      \texttt{NEq} was more complicated (different ways \texttt{Nat}s can be
    %	  not equal)
    %\item explain how only \texttt{LTE} is required for that selection of
    %	  operators?
    %   \item \textbf{explain the structure of operators and decidability rules}
    %\item \texttt{And} was already implemented with custom types, used this as
    %	  inspiration for implementation of \texttt{Or}
    \item explain how these `building blocks'/operators go together (similar to
    	  a stack-based language)?
\end{itemize}

When writing C programs for embedded systems, the programmer might want to capture extra-functional properties like the time taken or the energy consumed. Furthermore, the programmer may want to have provable guarantees that these properties of the program hold. This is done through contracts which can be proven using the \Idris proof system. The Contract Specification Language (CSL) works by declaring C variables, and then using these in the \Idris-based EDSL. By using an EDSL, the programmer does not need to change tools/libraries or learn a new language. Instead, the annotations seamlessly integrate with the existing code. When compiling the CSL, the variables are translated to \texttt{Var} types, numbers are translated to \texttt{Lit} types, all of which can then be evaluated using the given \texttt{Env}.
\\\par

The following section (\ref{des:tp-dsl}) focuses on describing existing work done by the \textsc{TeamPlay} project \cite{teamplay:d1.1}.

\section{The TeamPlay DSL}\label{des:tp-dsl}
    % TODO: explain `assert` + contracts before the mapping
    \subsection{C to DSL mappings}
        \begin{tabular}{c | c}
            \textbf{C operator} &   \textsc{TeamPlay} \textbf{DSL equivalent}   \\
            \hline
            \texttt{==}         &   \texttt{Eq}     \\
            \texttt{!=}         &   \texttt{NEq}    \\
            \texttt{<=}         &   \texttt{LTE}    \\
            \texttt{<}          &   \texttt{LT}     \\
            \texttt{>=}         &   \texttt{GTE}    \\
            \texttt{>}          &   \texttt{GT}     \\
            \texttt{\&\&}       &   \texttt{And}    \\
            \texttt{||}         &   \texttt{Or}     \\
            \texttt{!}          &   \texttt{Not}
        \end{tabular}
    
    \subsection{Numeric Operators and Numeric Expressions}
        The numeric operators all take two arguments, their evaluation, a proof concerning what the operator evaluates to, and returns a \texttt{BooleanExpression}.
        The operands are \texttt{NumericExpression}s. A \texttt{NumericExpression} is defined by the following grammar:
        \setlength{\grammarindent}{12em}
        \begin{grammar}
            <NumericExpression>
            ::=  ; a literal\\
                 `Lit' <digit>$^+$
            \alt ; a variable\\
                 `Var' <identifier>
            \alt ; a parenthesised expression\\
                 `NParen' <NumericExpression>
            \alt ; addition\\
                 `Plus' <NumericExpression> <NumericExpression>
            \alt ; subtraction\\
                 `Sub' <NumericExpression> <NumericExpression>
            \alt ; multiplication\\
                 `Mul' <NumericExpression> <NumericExpression>
            \alt ; division\\
                 `Div' <NumericExpression> <NumericExpression>
            \alt ; modulo\\
                 `Mod' <NumericExpression> <NumericExpression>
        \end{grammar}
        \texttt{NumericExpression}s are evaluated given an environment \texttt{Env}. The environment is essentially a mapping from symbols to values.
        \begin{code}[caption={The type of the \texttt{eval} function}]
            eval : Env -> NumericExpression -> Nat
        \end{code}
        The \texttt{eval} function uses this to evaluate a \texttt{NumericExpression}: Given an \texttt{Env} and a \texttt{NumericExpression}, the \texttt{eval} function returns a natural number. This is the result of that \texttt{NumericExpression} over that environment. To use the evaluation in a proof, we use the \texttt{Evald} type.
        \begin{code}[caption={\texttt{Evald} as defined in the \Idris model},label={des:evald}]
    data Evald : NumericExpression -> Nat -> Type where
        MkEvald : (x : NumericExpression) -> (y : Nat) -> Evald x y
        \end{code}
        Listing \ref{des:evald} shows that \texttt{Evald} is a data type constructed from a \texttt{NumericExpression} and \texttt{Nat}. This  is because \texttt{eval} only evaluates the expression, it does not provide a proof linking the evaluated value and the original expression. The \texttt{Evald} type `links' the numeric expression (\texttt{x}) and its evaluation (\texttt{y}), proving that \texttt{x} evaluates to \texttt{y}.
        \\
        
        When applying a numeric operator to some \texttt{NumericExpression}s, we get a \texttt{BooleanExpression}.
    
    \subsection{Boolean Operators and Boolean Expressions}
        Boolean expressions result from either a numeric operator or a boolean operator. The grammar for constructing boolean expressions is:
        \setlength{\grammarindent}{11em}
        \begin{grammar}
            <BooleanExpression>
            ::=  ; a paranthesised expression\\
            `BParen' <BooleanExpression>
            \alt ; the negation of an expression\\
            `Not' <BooleanExpression>
            \alt ; the conjunction of two expressions\\
            `And' <BooleanExpression> <BooleanExpression>
            \alt ; the disjunction of two expressions\\
            `Or' <BooleanExpression> <BooleanExpression>
            \alt ; testing two numbers for equality\\
            `Eq' <NumericExpression> <NumericExpression>
            \alt ; testing two numbers for inequality\\
            `NEq' <NumericExpression> <NumericExpression>
            \alt ; whether one number is strictly less than the other\\
            `LT' <NumericExpression> <NumericExpression>
            \alt ; whether one number is less than or equal to the other\\
            `LTE' <NumericExpression> <NumericExpression>
            \alt ; whether one number is strictly greater than the other\\
            `GT' <NumericExpression> <NumericExpression>
            \alt ; whether one number is greater than or equal to the other\\
            `GTE' <NumericExpression> <NumericExpression>
        \end{grammar}
        Similar to \texttt{NumericExpressions}, \texttt{BooleanExpressions} are evaluated over an environment.
        \begin{code}[caption={The type of the \texttt{beval} function}]
            beval : Env -> BooleanExpression -> Bool
        \end{code}
        Given an \texttt{Env} and a \texttt{BooleanExpression}, the \texttt{beval} function returns a boolean. This boolean is the result of evaluating that \texttt{BooleanExpression} over that environment. Like with \texttt{NumericExpressions}, to use the evaluation in a proof, we have the \texttt{BEvald} type.
        \begin{code}[caption={\texttt{BEvald} as defined in the \Idris model}]
data BEvald : BooleanExpression -> Nat -> Type where
    MkBEvald : (x : BooleanExpression) -> (y : Bool) -> BEvald x y
        \end{code}
        \texttt{BEvald} works like \texttt{Evald} except for boolean expressions and values. It is a data type constructed from a \texttt{BooleanExpression} and a \texttt{Bool}. Like \texttt{eval}, the \texttt{beval} function only evaluates the value of the boolean expression, it does not provide a proof that the expression evaluates to that boolean. The \texttt{BEval} type is a proof that the boolean expression \texttt{x} evaluates to the boolean \texttt{y}.
        \\
        
        The operators \texttt{And}, \texttt{Eq}, \texttt{LT}, \texttt{LTE}, \texttt{GT}, and \texttt{GTE} were already implemented. So in order to have a complete set of operators, I implemented \texttt{NEq}, \texttt{Or}, and \texttt{Not}.

\section{Inequality (\texttt{NEq})}
    % TODO: Rewrite this bit
    \texttt{Eq} had already been implemented by the \textsc{TeamPlay} project as part of the D1.1 deliverable \cite{teamplay:d1.1}.
    \textbf{TODO}
    
    I implemented \texttt{NEq} by doing the `opposite' of \texttt{decEq} (Listing \ref{lst:decEq}). There are three cases under which natural numbers can be not equal, two base-cases and one general case. The cases are the constructors for the \texttt{TyNEq} type:
    \begin{code}[caption={\texttt{TyNEq}} -- proving inequality.]
        data TyNEq : Nat -> Nat -> Type where
        MkNEqL   : TyNEq Z (S k)
        MkNEqR   : TyNEq (S k) Z
        MkNEqRec : TyNEq k j -> TyNEq (S k) (S j)
    \end{code}
    \begin{enumerate}
        \item \textbf{The first number is zero and the second is not} -- in this case the numbers are not equal, specifically the left number is zero. Since no number can have zero as its successor, the numbers are not equal.
        \item \textbf{The second number is zero and the first is not} -- in this case, the numbers are not equal, specifically the right number is zero. Since no number can have zero as its successor, the numbers are not equal.
        \item \textbf{The numbers are not equal} -- in this case, the successors of the numbers must also be not equal.
    \end{enumerate}
    This guarantees that a \texttt{TyNEq} can only be constructed if the numbers are truly not equal and hence allows for the definition of decidability rules for inequality.
    \begin{code}[caption={Decidability rules for inequality}]
    -- if both numbers are zero, we cannot construct a TyNEq as
    -- its constructors require one of the numbers to be non-zero
    implementation Uninhabited (TyNEq Z Z) where
        uninhabited MkNEqL impossible
        uninhabited MkNEqR impossible

    -- if the numbers are equal, we cannot construct a TyNEq for      
    -- the successors as neither successor can be zero
    proveSuccEq : TyNEq (S k) (S j) -> Void
    proveSuccEq MkNEqL impossible
    proveSuccEq MkNEqR impossible
    
    -- if we have a recursive counter-proof for k and j, the
    -- counter-proof for their successors is 'included'
    proveNEqRec : (contra : TyNEq k j -> Void) ->
                  TyNEq (S k) (S j) -> Void
    proveNEqRec contra (MkNEqRec x) = contra x
    
    -- decidability rules for "NEq"
    isNEq : (n1 : Nat) -> (n2 : Nat) -> Dec (TyNEq n1 n2)
    isNEq Z Z         = No absurd
    isNEq Z (S k)     = Yes MkNEqL
    isNEq (S k) Z     = Yes MkNEqR
    isNEq (S k) (S j) = case isNEq k j of
                            Yes prf => Yes (MkNEqRec prf)
                            No contra => No (proveNEqRec contra)
    \end{code}
    
    With decidability rules for \texttt{NEq}, inequality could now be proven (see Section \ref{evaln:ops:neq})
    
\section{Boolean Disjunction (\texttt{Or})}
    The boolean operators are made up of different stages: Constructors for boolean expressions which evaluate to true, the operators keywords, an evaluation of the boolean expression, and a proof of what the boolean expression evaluates to. Boolean conjunction (\texttt{And}) was already implemented. I used it as a starting point for how to implement \texttt{Or}, as they are somewhat similar.
    
    \begin{code}[label={des:tyand-or}, caption={The constructors for true \texttt{And} and \texttt{Or} statements}, escapeinside={(*}{*)}]
        mutual
            data TyAnd : Bool -> Bool -> Type where
                MkAnd  : TyAnd True True
            
            data TyOr : Bool -> Bool -> Type where
                MkOr  : TyOr True True
                MkOrL : TyOr True False
                MkOrR : TyOr False True
    \end{code}

    There is only one case where \texttt{And} evaluates to true, i.e. \texttt{And True True}. This is reflected in that the only constructor for \texttt{TyAnd} has to have both arguments be \texttt{True}. With this idea in mind, the constructors for \texttt{Or} can be implemented. \texttt{TyOr} can be constructed when the expression evaluates to true, i.e. in three cases:
    \begin{itemize}
        \item both arguments are \texttt{True}, \texttt{Or True True}
        \item the left argument is \texttt{True}, \texttt{Or True False}
        \item the right argument is \texttt{True}, \texttt{Or False True}
    \end{itemize}
    
    With constructors for \texttt{TyOr}, we can then define the \texttt{Or} operator similar to the \texttt{And} operator.
    
    \newpage
    
    \begin{code}[caption={The definitions of \texttt{And} and \texttt{Or}}, escapeinside={(*}{*)}]
            data BooleanExpression : Type where
                (*\vdots*)
                
                And :  (x : BooleanExpression)
                    -> (y : BooleanExpression)
                    -> BEvald x x'
                    -> BEvald y y'
                    -> Dec (TyAnd x' y')
                    -> BooleanExpression
                
                Or  :  (x : BooleanExpression)
                    -> (y : BooleanExpression)
                    -> BEvald x x'
                    -> BEvald y y'
                    -> Dec (TyOr x' y')
                    -> BooleanExpression
                (*\vdots*)
    \end{code}

    \texttt{And} takes 5 arguments: two boolean expressions, the proofs of what these evaluated to, and decidable proof of whether those arguments would cause the \texttt{And} to evaluate to true. From the constructors of \texttt{TyAnd} (Listing \ref{des:tyand-or}), this can only be constructed when both arguments are \texttt{True}, i.e. when the \texttt{And} would evaluate to \texttt{True}. Based on this, \texttt{And} returns a new \texttt{BooleanExpression} (which can then be evaluated using the \texttt{beval} function). \texttt{Or} takes the same first 4 arguments. The difference being that its 5$^{th}$ argument is a decidable proof of whether those arguments would cause the \texttt{Or} to evaluate to \texttt{True}. From the constructors of \texttt{TyOr} (Listing \ref{des:tyand-or}), this can only be constructed if one or both of the arguments is \texttt{True}, i.e. the \texttt{Or} would evaluate to \texttt{True}. Based on its arguments, \texttt{Or} then returns a new \texttt{BooleanExpression} (which can then be evaluated using the \texttt{beval} function). Both \texttt{And} and \texttt{Or} rely on \texttt{Dec}, i.e. that a proof that it cannot evaluate to \texttt{True} exists.
    
    \begin{code}[caption={Impossible \texttt{And} cases}]
        implementation Uninhabited (TyAnd False True) where
            uninhabited MkAnd impossible
            
        implementation Uninhabited (TyAnd True False) where
            uninhabited MkAnd impossible
            
        implementation Uninhabited (TyAnd False False) where
            uninhabited MkAnd impossible
    \end{code}

    Since \texttt{MkAnd} requires both arguments to be \texttt{True}, an implementation of \texttt{Uninhabited} can be given for the other three cases. In each of the cases, the \texttt{And} would evaluate to \texttt{False}. With an implementation of \texttt{Uninhabited}, we can provide a proof for each case that it is impossible to construct a \texttt{MkAnd} and as such, the expression must evaluate to \texttt{False}. For \texttt{Or} there is only one case which evaluates to \texttt{False}.
    
    \begin{code}[caption={The impossible \texttt{Or} case}]
        implementation Uninhabited (TyOr False False) where
            uninhabited MkOr  impossible
            uninhabited MkOrL impossible
            uninhabited MkOrR impossible
    \end{code}

    \texttt{MkOr} requires at least one of the arguments to be \texttt{True} (see Listing \ref{des:tyand-or}). As such, the case where we would have a \texttt{TyOr False False} is impossible. None of the constructors provided for \texttt{TyOr} can be used on \texttt{False False}, so a \texttt{TyOr} cannot exist. This means the \texttt{Or} cannot evaluate to \texttt{True}, i.e. we have a proof that it must evaluate to \texttt{False}.

\section{Boolean Negation (\texttt{Not})}
    Boolean negation was also implemented using a custom proof type. The only case where negation evaluates to true is when negating false. Therefore, it is only possible to construct a \texttt{TyBNot} if the given \texttt{BooleanExpression} was false:
    \begin{code}[caption={The proof type for \texttt{Not}}]
        data TyBNot : Bool -> Type where
            MkBNot  : TyBNot False
    \end{code}
    This time, only a single counter-proof is needed, i.e. \texttt{Not True}:
    \begin{code}[caption={Constructing \texttt{Not True} is impossible}]
        implementation Uninhabited (TyBNot True) where
            uninhabited MkBNot impossible
    \end{code}
    From this, the decidability rules are trivial:
    \begin{code}[caption={Decidability rules for \texttt{Not}}]
        isNot : (b : Bool) -> Dec (TyBNot b)
        isNot False = Yes MkBNot
        isNot True  = No absurd
    \end{code}
    As before, \texttt{beval} was extended to also be able to evaluate \texttt{Not}:
    \begin{code}[caption={\texttt{beval} for \texttt{Not}}, escapeinside={(*}{*)}]
        beval : (env : Env) -> (b : BooleanExpression) -> Bool
            (*\vdots*)
        beval env (Not x x' (Yes prf))   = True
        beval env (Not x x' (No contra)) = False
            (*\vdots*)
    \end{code}
    
    An evaluation of \texttt{Not} can be found in Section \ref{evaln:ops:not}.
    
    
