In order to be able to use the existing operators, and the ones I had implemented, in code, I needed to make sure that they worked, i.e. that they did not return anything unexpected (e.g., \texttt{Eq} should not evaluate to true for 1 and 3, and \texttt{And False False} should not evaluate to \texttt{True}). This is the described in the first section (\ref{evaln:ops}) of this chapter. With working operators, it should then be possible to construct slightly more complex C programs, and annotate and model them using the framework. This is described in the second section (\ref{evaln:progs}).


\section{Operators}\label{evaln:ops}
    In order to evaluate the operators, I constructed multiple examples which tested specific input cases/categories and asserted that they functioned as expected in each case. For numeric operators, I tested the following input cases:
    \begin{itemize}
        \item zero and zero -- they form the base case of natural numbers so for
              all recursive operations to be correct, the base case has to be correct
        \item zero and one or one and zero -- since one is the immediate
              successor of zero, there is only the need for one recursive step,
              so if this case works, adding more recursive steps is likely to 
              work
        \item numbers greater than zero and one -- these require multiple 
              recursive steps and so if they work, all numbers should work as
              we then know that recursion works
    \end{itemize}
    \todo{wording?...}
    
    For boolean operators, I tested the possible combinations of \texttt{True} and \texttt{False} for the operator and compared the results with the corresponding truth-table for the corresponding logical operator.
	
    \subsection{The \texttt{Eq} Operator}\label{evaln:ops:eq}
        \lstinputlisting[caption={A C program which requires $0 = 0$}]{"../Idris_Stuff/Examples/Eq/Eq_0_0.c"}
        
        The C program itself may not seem very interesting. However, it is a structurally correct C program. Its purpose is to test the base case of equality between natural numbers: that zero equals zero. This equality assertion would be similar for larger, more complex programs using the annotation.
        
		\idrisinput{"../Idris_Stuff/Examples/Eq/Eq_0_0.idr"}
        
        Transforming the C annotation into \Idris, we get the model detailed above. The model `\texttt{eq\_0\_0} is a \texttt{CLang} consisting of an assertion named `\texttt{eq\_0\_0\_assert}' and nothing more (\texttt{Halt}). This assertion contains two literals \texttt{x} and \texttt{y} both carrying the value 0, their evaluation \texttt{x'} and \texttt{y'} over a given environment \texttt{env}, and a decidable proof \texttt{prf} that the numbers are equal. Using these, we can use \texttt{MkAssertion} (\todo{listing}) to construct an instance of \texttt{Assertion} (\todo{listing}).
        
        \newpage
        
        \begin{code}
Idris> mkCertificate eq_0_0
        \end{code}
		\idrisinput{"../Idris_Stuff/Examples/Eq/Eq_0_0.out"}
        
        Using the \texttt{mkCertificate} function, we construct a certificate based on the \texttt{Assertion} made. We can see that the evaluation of the literals has worked correctly from \texttt{MkEvald (Lit 0) 0}. The final argument to the \texttt{MkAssertion} is a \texttt{Yes Refl}, so the \texttt{Eq} operator worked for zero and zero: It found that they were equal, which is correct.
        \\
        
        \lstinputlisting[caption={A C program which requires $1 = 1$}]{"../Idris_Stuff/Examples/Eq/Eq_1_1.c"}
        
        Again, the actual C program is structurally sound. The assertion tests that 1 equals 1, as one is the immediate successor of zero and hence only requires one recursive step.
        
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_1.idr"}
        
        The resulting \Idris model `\texttt{eq\_1\_1}' contains an assertion that 1 equals 1 (\texttt{Assert eq\_1\_1\_assert}) and nothing more (\texttt{Halt}). This assertion in turn contains the two literals (\texttt{x} and \texttt{y}) both carrying a value of 1 (\texttt{Lit 1}), their evaluation over the given environment (\texttt{x'} and \texttt{y'}), and a decidable proof `\texttt{prf}' that the evaluations are equal.
        
        \begin{code}
Idris> mkCertificate eq_1_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_1.out"}
        
        When passing \texttt{eq\_1\_1} through the \texttt{mkCertificate} function, we see that the evaluations were correct (from \texttt{MkEvald (Lit 1) 1}). The final argument to \texttt{MkAssertion} contains a \texttt{Yes Refl}, so the model has confirmed that $1 = 1$ and as such, that \texttt{Eq} works for 1.
        \\
        
        
        \lstinputlisting[label={evaln:ops:eq-0-1}, caption={A C program which requires $0 = 1$}]{"../Idris_Stuff/Examples/Eq/Eq_0_1.c"}
        
        With $0 = 0$ and $1 = 1$ working, I evaluated that the operator was working correctly for 0 and 1 by testing that $0 = 1$ and $1 = 0$ did not produce a \texttt{Yes Refl}.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_0_1.idr"}
        
        This time, the \Idris model contains two numerically different literals, their evaluation, and a decidable proof of whether they are equal or not.
        
        \begin{code}
Idris> mkCertificate eq_0_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_0_1.out"}
        
        The output from the \texttt{mkCertificate} function over \texttt{eq\_0\_1} shows the literals were evaluated correctly. The proof argument this time contains \texttt{No ZnotS}. This is the built-in version of the proof that zero cannot be the successor of a natural number (Listing \ref{idr:zns}). Given that 0 and 1 were the arguments to \texttt{Eq}, the operator has worked correctly: zero and one are not equal, because zero cannot be the successor of any natural number.
        
        The details of the vice-versa of this, i.e. $1 = 0$ not returning \texttt{Yes Refl}, can be found in Appendix \ref{app:evaln}, Section \ref{app:evaln:ops:eq}. The output from \texttt{mkCertificate} function is slightly unusual, and as such is included here.
        
        \newpage
        
        \begin{code}
Idris> mkCertificate eq_1_0
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_0.out"}
        
        However, the certificate produced is slightly unexpected: it still contains \texttt{ZnotS}, this time combined with a function `\texttt{negEqSym}'. The \texttt{negEqSym} function has the following type:\par
        \texttt{negEqSym : ((a = b) -> Void) -> (b = a) -> Void}\\
        Essentially, the \texttt{negEqSym} proves that if two numbers are not equal, then swapping them around does not change that fact; It proves/states that the negation of equality is \textit{symmetric}. Hence, \texttt{ZnotS} can also be used to prove that $1 = 0$ is false as it is symmetric to proving $0 = 1$ is false. So the \texttt{Eq} operator works correctly when asserting $1 = 0$.
        
        \lstinputlisting[label={evaln:ops:eq-3-3}, caption={A C program which requires $3 = 3$}]{"../Idris_Stuff/Examples/Eq/Eq_3_3.c"}
        
        With both zero and one working, the remaining case is to test that \texttt{Eq} works with multiple recursive calls, i.e. any natural number greater than 1.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_3_3.idr"}
        
        The \texttt{eq\_3\_3} model contains two `3'-literals, their evaluation over the given environment, and a decidable proof that the two evaluations are equal.
        
        \begin{code}
Idris> mkCertificate eq_3_3
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_3_3.out"}
        
        Both evaluations returned 3 as expected and the final argument to \texttt{MkAssertion} is a \texttt{Yes Refl}. Hence, the \texttt{Eq} operator works for numbers greater than 0 and 1; It works in general.
        
        \lstinputlisting[label={evaln:ops:eq-1-3}, caption={A C program which requires $1 = 3$}]{"../Idris_Stuff/Examples/Eq/Eq_1_3.c"}
        
        Finally, to make sure that the operator disproves incorrect equalities for numbers greater than 1, I used the C program above.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_3.idr"}
        
        The model contains the literals `1' and `3', their evaluation over the given environment, and a decidable proof of their equality.
        
        \begin{code}
Idris> mkCertificate eq_1_3
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_3.out"}
        
        Both evaluations match with the literals. The final argument in the \texttt{MkAssertion} argument uses a lambda function and the \texttt{succInjective} function. It has the type:\par
        \texttt{succInjective : (left : Nat) -> (right : Nat) -> (p : S left = S right) -> left = right}\\
        It takes two numbers and proves that if the successor of the left number is reflexive to the successor of the right number, then the numbers themselves must be equal. The argument \texttt{h} is a proof that \texttt{0 = S k}, so if it exists, then we could create a \texttt{Void}. This is a contradiction, so the equality is impossible. Swapping the operands results in almost the same proof.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_3_1.out"}
        
        The only difference between this output is that it uses the \texttt{sym} function. Like with $0 = 1$ and $1 = 0$, this proves that numbers not being equal is symmetrical, so the same proof that they are not equal can be used. These two examples ($1 = 3$ and $3 = 1$), combined with the example in Listing \ref{evaln:ops:eq-3-3}, shows that the \texttt{Eq} function (and by extension, the \texttt{==} operator) works as intended for numbers greater than 0 and 1: if they are equal, then \texttt{Eq} proves it, and if they are not equal, then it correctly produces a proof as to why this is.
    
    \subsection{The \texttt{NEq} Operator}\label{evaln:ops:neq}
        \lstinputlisting[label={evaln:ops:neq-0-1}, caption={A C program requiring $0 \neq 1$}]{"../Idris_Stuff/Examples/NEq/NEq_0_1.c"}
        
        The C program for testing inequality is syntactically correct. Any more complex program which was trying to assert an inequality at some point would use the same annotation and operator.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_0_1.idr"}
        
        The resulting \Idris model contains the literals 0 and 1, their evaluation, and a decidable proof of whether they are equal or not. These are passed as arguments to the \texttt{NEq} function, which is in turn used to construct an \texttt{Assertion} using \texttt{MkAssertion}.
        
        \begin{code}
Idris> mkCertificate neq_0_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_0_1.out"}
        
        Constructing the certificate using the \texttt{mkCertificate} function shows that the last argument to \texttt{NEq} was a \texttt{Yes MkNEqL}, i.e. that the numbers are not equal, specifically because the left number was smaller than the right number, \texttt{MkNEqL}.
        
        \newpage
        
        \begin{code}
Idris> mkCertificate neq_1_0
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_1_0.out"}
        
        Switching the operands around does not change the C program or the model much (see Appendix \ref{app:evaln}, Section \ref{app:evaln:ops:neq}). However, the resulting certificate is slightly different: the numbers are still shown to be not equal (the certificate contains a \texttt{Yes}) but this time specifically because the right number was smaller than the left number, \texttt{MkNEqR}.
        For the arguments 0 and 1 the \texttt{NEq} function evaluates correctly that the numbers are not equal, regardless of which side of the operator they are on.
        
        
        \lstinputlisting[label={evaln:ops:neq-0-0}, caption={A C program requiring $0 \neq 0$}]{"../Idris_Stuff/Examples/NEq/NEq_0_0.c"}
        
        Since the program requires 0 to be not equal to 0, the \texttt{NEq} operator should evaluate to false.
        
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_0_0.idr"}
        
        The \Idris model contains two literals, both carrying the value 0, their evaluation, and a decidable proof of whether they are not equal.
        
        \begin{code}
Idris> mkCertificate neq_0_0
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_0_0.out"}
        
        Constructing a certificate shows that the numbers are not unequal (\texttt{No}). The proof that they cannot be unequal is the \texttt{absurd} function, which can be used thanks to the implementation of \texttt{Uninhabited} that we provided in Section \ref{des:neq}, Listing \ref{des:neq-uninh}.
        
        \begin{code}
Idris> mkCertificate neq_1_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_1_1.out"}
        
        Changing the operands to 1, i.e. having a program which requires the immediate successor of 0 to be not equal to itself (Appendix \ref{app:evaln}, Section \ref{app:evaln:ops:neq}) results in a similar certificate. The proof that this cannot be is still `\texttt{absurd}', but passed through the \texttt{succNEqImpossible} function (detailed in Listing \ref{des:neq-sneqimp}) which proves that if two numbers are proven to not be unequal, then their successors must also not be unequal.
        \\
        
        With these examples, the \texttt{NEq} operator has been shown to work for for the base case, 0, and its immediate successor, 1. For numbers greater than these, more recursive steps are required.
        
        \newpage
    
        \lstinputlisting[label={evaln:ops:neq-2-5}, caption={A C program requiring $2 \neq 5$}]{"../Idris_Stuff/Examples/NEq/NEq_2_5.c"}
        
        Both 2 and 5 are greater than 0 and 1, and so are not part of the base cases. Since they are higher successors, they should require more recursive steps to show that they are not equal. If it works, then the recursive step works and so any natural number would work.
        
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_2_5.idr"}
        
        Constructing the model, we have the literals 2 and 5, their evaluation over a given environment, and a decidable proof of their inequality. This is passed to the \texttt{NEq} constructor to construct a \texttt{BooleanExpression} which is then passed to the \texttt{MkAssertion} constructor.
        
        \begin{code}
Idris> mkCertificate neq_2_5
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_2_5.out"}
        
        Creating a certificate based on the model shows that the literals have been correctly evaluated and associated. It was also possible to construct a proof that the numbers are not equal (the \texttt{Yes} part of the certificate). As can be seen by the repeated \texttt{MkNEqRec} constructor in the proof, the recursive step works; The left number is smaller (\texttt{MkNEqL}), specifically it is 3 smaller (1 smaller + 2 recursive steps). Swapping the operands and generating the resulting model (Appendix \ref{app:evaln}, Section \ref{app:evaln:ops:neq}) should result in a similar result.
        
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_5_2.out"}
        
        Having swapped the order of the operands, the resulting certificate is very similar to the previous one. The literals have swapped order, and the two recursive steps are still there. However, this time the numbers are not equal specifically because right number has been shown to be smaller (\texttt{MkNEqR}). So the \texttt{NEq} operator can show that natural numbers greater than 0 and 1 are not equal. However, we still need to show that it can disprove the inequality between numbers greater than 0 and 1.
        
        \lstinputlisting[caption={A C program requiring $3 \neq 3$}]{"../Idris_Stuff/Examples/NEq/NEq_3_3.c"}
        
        To completely test that the operator works correctly for numbers greater than 0 and 1, the above C program requires that 3 be not equal to itself. This should evaluate to false. If it does, then since 3 requires multiple recursive steps, the operator can prove that two numbers greater than 0 and 1 cannot be unequal.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_3_3.idr"}
        
        The \Idris model has two literals carrying the value 3, their evaluation over a given environment, and a decidable proof of whether they are not equal.
        
        \begin{code}
Idris> mkCertificate neq_3_3
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_3_3.out"}
        
        The resulting certificate shows that the literals were evaluated correctly and that the numbers were shown to not be unequal (the \texttt{No} part in the certificate). Similar to the example for $1 \neq 1$, the proof of this is the \texttt{absurd} function, but this time recursively passed through the \texttt{succNEqImpossible} function three times (due to the number being 3). This shows that the \texttt{NEq} operator works correctly in terms of proving that two natural numbers greater than 0 and 1 cannot be unequal.
        \\
        
        Having shown that the \texttt{NEq} operator works correctly for the base case (0), its immediate successor (1), and natural numbers greater than these, we can conclude that the \texttt{NEq} operator works as intended.
        
    \newpage
    
    \subsection{The \texttt{LTE} Operator}
        \lstinputlisting[label={evaln:ops:lte-0-0}, caption={A C program which requires $0 \leq 0$}]{"../Idris_Stuff/Examples/LTE/LTE_0_0.c"}
        
        This C program captures the essential structure of a program requiring that a property be less than or equal to another. It has a function, two properties compared by the less-than-or-equals (LTE) operator, and the \texttt{assert} annotation.
        
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_0_0.idr"}
        
        Translating this to an \Idris model we get two literals both carrying the value 0, their evaluation over a given environment, and a decidable proof of whether the first is less than or equal to the second. These are passed to the \texttt{LTE} constructor to create a \texttt{BooleanExpression} which is used to create an \texttt{Assertion}.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_0_0.out"}
        
        The resulting certificate shows that the literals were evaluated correctly, and the \texttt{Yes} on the last line shows that we successfully proved that 0 is less than or equal to 0. The \texttt{LTEZero} proof is part of the \Idris prelude and states that zero is the smallest natural number, so any natural number is less than or equal to it.
        
        \begin{code}
Idris> mkCertificate lte_0_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_0_1.out"}
        
        The certificate created by asserting $0 \leq 1$ is identical (apart from the `1'-literal) due to it still involving zero on the left-hand side.
        \todo{explain how other LTE-Zero proofs relate}
        
        \lstinputlisting[caption={A C program which requires $1 \leq 1$}]{"../Idris_Stuff/Examples/LTE/LTE_1_1.c"}
        
        Again, the program has the same core structure as any which would assert that one property was LTE to the other. This time both properties are 1 to test that the operator works with the immediate successor of 0.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_1_1.idr"}
        
        The resulting \Idris model has two literals both carrying their the value 1, their evaluation over the given environment, and a decidable proof of the first being LTE to the other.
        
        \begin{code}
Idris> mkCertificate lte_1_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_1_1.out"}
        
        Passing the model through the \texttt{mkCertificate} function, we see that it has successfully evaluated the literals and proven that 1 is LTE than itself, by applying \texttt{LTEZero} using the \texttt{LTESucc} function. It has type:\\
        \texttt{LTESucc : LTE left right -> LTE (S left) (S right)}\\
        The \texttt{LTESucc} function takes a proof that two numbers are LTE to each other, and proves than in that case, so are their successors. So \texttt{Yes (LTESucc LTEZero)} says that since 0 is LTE to any natural number $n$, $(0 + 1)$ is LTE to any natural number $(n + 1)$.
        
        \newpage
        
        \lstinputlisting[caption={A C program requiring $1 \leq 3$}]{"../Idris_Stuff/Examples/LTE/LTE_1_3.c"}
        
        For the case where zero is not on the left-hand side, recursive steps should be required.
        
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_1_3.idr"}
        
        The resulting model this time contains two non-zero literals (1 and 3 respectively), their evaluation over a given environment, and a decidable proof that the left is LTE to the right.
        
        \begin{code}
            Idris> mkCertificate lte_1_3
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_1_3.out"}
        
        The certificate shows that the evaluation successfully proved the comparison to be true. The specifics of the proof show that the left-hand side reached 0 before (or at the same time as) the right-hand side did, so we can apply the \texttt{LTEZero} proof to that side using the \texttt{LTESucc} function (in this case once, to reach 1).
        
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_3_3.out"}
        
        When having a left-hand side greater than 1, we can more clearly see the recursive step. Here, the \texttt{LTESucc} function is applied three times to the \texttt{LTEZero} proof, thereby proving that the left-hand side `3' reached 0 before, or at the same time as, the right-hand side and therefore it is LTE to the right-hand side.
        
        \todo{false examples}
        
        \todo{put the other ops in appendix}
    
    \subsection{The \texttt{Or} Operator}\label{evaln:ops:or}
        \lstinputlisting{"../Idris_Stuff/Examples/Or/Or_t_t.c"}
        \todo{true or true}
    
        \lstinputlisting{"../Idris_Stuff/Examples/Or/Or_f_t.c"}
        \todo{false or true}
    
        \lstinputlisting{"../Idris_Stuff/Examples/Or/Or_t_f.c"}
        \todo{true or false}
        
        \lstinputlisting{"../Idris_Stuff/Examples/Or/Or_t_f.c"}
        \todo{false or false}
    
    \subsection{The \texttt{Not} Operator}\label{evaln:ops:not}
        \lstinputlisting{"../Idris_Stuff/Examples/Not/Not_false.c"}
        \todo{not false}
        
        \lstinputlisting{"../Idris_Stuff/Examples/Not/Not_true.c"}
        \todo{not true}

\newpage


\section{Simple Programs}\label{evaln:progs}
    \subsection{Loop accumulation}
        \lstinputlisting[caption={A C program whose loop has a timing requirement.}]{"../Idris_Stuff/Examples/Advanced/Loop.c"}
