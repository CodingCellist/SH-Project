In order to be able to use the existing operators, and the ones I had implemented, in code, I needed to make sure that they worked, i.e. that they did not return anything unexpected (e.g., \texttt{Eq} should not evaluate to true for 1 and 3, and \texttt{And False False} should not evaluate to \texttt{True}). This is the described in the first section (\ref{evaln:ops}) of this chapter. With working operators, it should then be possible to construct slightly more complex C programs, and annotate and model them using the framework. This is described in the second section (\ref{evaln:progs}).


\section{Operators}\label{evaln:ops}
    In order to evaluate the operators, I constructed multiple examples which tested specific input cases/categories and asserted that they functioned as expected in each case. For numeric operators, I tested the following input cases:
    \begin{itemize}
        \item zero and zero -- they form the base case of natural numbers so for
              all recursive operations to be correct, the base case has to be correct
        \item zero and one or one and zero -- since one is the immediate
              successor of zero, there is only the need for one recursive step,
              so if this case works, adding more recursive steps is likely to 
              work
        \item numbers greater than zero and one -- these require multiple 
              recursive steps and so if they work, all numbers should work as
              we then know that recursion works
    \end{itemize}
    \todo{wording?...}
    
    For boolean operators, I tested the possible combinations of \texttt{True} and \texttt{False} for the operator and compared the results with the corresponding truth-table for the corresponding logical operator.
	
    \subsection{The \texttt{Eq} Operator}\label{evaln:ops:eq}
        \lstinputlisting[caption={A simple C program which requires $0 = 0$}]{"../Idris_Stuff/Examples/Eq/Eq_0_0.c"}
        
        The C program itself does not do anything. Its purpose is to test the base case of equality between natural numbers: that zero equals zero.
        
		\idrisinput{"../Idris_Stuff/Examples/Eq/Eq_0_0.idr"}
        
        Transforming the C annotation into \Idris, we get the model detailed above. The model `\texttt{eq\_0\_0} is a \texttt{CLang} consisting of an assertion named `\texttt{eq\_0\_0\_assert}' and nothing more (\texttt{Halt}). This assertion contains two literals \texttt{x} and \texttt{y} both carrying the value 0, their evaluation \texttt{x'} and \texttt{y'} over a given environment \texttt{env}, and a decidable proof \texttt{prf} that the numbers are equal. Using these, we can use \texttt{MkAssertion} (\todo{listing}) to construct an instance of \texttt{Assertion} (\todo{listing}).
        
        \begin{code}
Idris> mkCertificate eq_0_0
        \end{code}
		\idrisinput{"../Idris_Stuff/Examples/Eq/Eq_0_0.out"}
        
        Using the \texttt{mkCertificate} function, we construct a certificate based on the \texttt{Assertion} made. We can see that the evaluation of the literals has worked correctly from \texttt{MkEvald (Lit 0) 0}. The final argument to the \texttt{MkAssertion} is a \texttt{Yes Refl}, so the \texttt{Eq} operator worked for zero and zero: It found that they were equal, which is correct.
        \\
        
        \lstinputlisting[caption={A simple C program which requires $1 = 1$}]{"../Idris_Stuff/Examples/Eq/Eq_1_1.c"}
        
        Again, the actual C program does not do anything interesting. The assertion tests that 1 equals 1 as this is the immediate successor of zero and hence only requires one recursive step.
        
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_1.idr"}
        
        The resulting \Idris model `\texttt{eq\_1\_1}' contains an assertion that 1 equals 1 (\texttt{Assert eq\_1\_1\_assert}) and nothing more (\texttt{Halt}). This assertion in turn contains the two literals (\texttt{x} and \texttt{y}) both carrying a value of 1 (\texttt{Lit 1}), their evaluation over the given environment (\texttt{x'} and \texttt{y'}), and a decidable proof `\texttt{prf}' that the evaluations are equal.
        
        \newpage
        
        \begin{code}
Idris> mkCertificate eq_1_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_1.out"}
        
        When passing \texttt{eq\_1\_1} through the \texttt{mkCertificate} function, we see that the evaluations were correct (from \texttt{MkEvald (Lit 1) 1}). The final argument to \texttt{MkAssertion} contains a \texttt{Yes Refl}, so the model has confirmed that $1 = 1$ and as such, that \texttt{Eq} works for 1.
        \\
        
        
        \lstinputlisting[caption={A simple C program which requires $0 = 1$...}]{"../Idris_Stuff/Examples/Eq/Eq_0_1.c"}
        
        With $0 = 0$ and $1 = 1$ working, I decided to confirm that the operator was working correctly for 0 and 1 by testing that $0 = 1$ and $1 = 0$ did not produce a \texttt{Yes Refl}.
        
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_0_1.idr"}
        
        Again, we get a model containing the literals, their evaluation, and a decidable proof of whether they are equal or not.
        
        \begin{code}
Idris> mkCertificate eq_0_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_0_1.out"}
        
        The output from the \texttt{mkCertificate} function over \texttt{eq\_0\_1} shows the literals were evaluated correctly. The proof argument this time contains \texttt{No ZnotS}. This is the built-in version of the proof that zero cannot be the successor of a natural number (Listing \ref{idr:zns}). Given that 0 and 1 were the arguments to \texttt{Eq}, the operator has worked correctly: zero and one are not equal, because zero cannot be the successor of any natural number.
        
        The details of the vice-versa of this, i.e. $1 = 0$ not returning \texttt{Yes Refl}, can be found in Appendix \ref{app:evaln}, Section \ref{app:evaln:ops:eq}.
        
        \begin{code}
Idris> mkCertificate eq_1_0
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_0.out"}
        However, the certificate produced is slightly unexpected: it still contains \texttt{ZnotS}, this time combined with a function `\texttt{negEqSym}'. The \texttt{negEqSym} function has the following type:\par
        \idrisinline{negEqSym : ((a = b) -> Void) -> (b = a) -> Void}\\
        Essentially, the \texttt{negEqSym} proves that if two numbers are not equal, then swapping them around does not change that fact; It proves/states that the negation of equality is \textit{symmetric}. Hence, \texttt{ZnotS} can also be used to prove that $1 = 0$ is false as it is symmetric to proving $0 = 1$ is false. So the \texttt{Eq} operator works correctly when asserting $1 = 0$.
        
        \newpage
        
        \lstinputlisting[caption={A simple C program which requires $3 = 3$}]{"../Idris_Stuff/Examples/Eq/Eq_3_3.c"}
        TODO
        \todo{3 == 3 true}
        \\
        
        \lstinputlisting[caption={A simple C program which requires $1 = 3$}]{"../Idris_Stuff/Examples/Eq/Eq_1_3.c"}
        \todo{1 and 3 false}
    
    \subsection{The \texttt{NEq} Operator}\label{evaln:ops:neq}
        \lstinputlisting{"../Idris_Stuff/Examples/NEq/NEq_2_5.c"}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_2_5.idr"}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_2_5.out"}
    
    \subsection{The \texttt{LTE} Operator}
    
    \subsection{The \texttt{LT} Operator}
    
    \subsection{The \texttt{GTE} Operator}
    
    \subsection{The \texttt{GT} Operator}
    
    \subsection{The \texttt{And} Operator}
    
    \subsection{The \texttt{Or} Operator}\label{evaln:ops:or}
        \idrisinput{"../Idris_Stuff/Examples/Or/Or_f_t.idr"}
        \idrisinput{"../Idris_Stuff/Examples/Or/Or_f_t.out"}
    
    \subsection{The \texttt{Not} Operator}\label{evaln:ops:not}
        \idrisinput{"../Idris_Stuff/Examples/Not/Not_false.idr"}
        \idrisinput{"../Idris_Stuff/Examples/Not/Not_false.out"}

\section{Simple Programs}\label{evaln:progs}
    \subsection{Loop accumulation}
