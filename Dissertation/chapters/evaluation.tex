In order to be able to use the existing operators, and the ones I had implemented, in code, I needed to make sure that they worked, i.e. that they did not return anything unexpected (e.g., \texttt{Eq} should not evaluate to true for 1 and 3, and \texttt{And False False} should not evaluate to \texttt{True}). This is the described in the first section (\ref{evaln:ops}) of this chapter. With working operators, it should then be possible to construct slightly more complex C programs, and annotate and model them using the framework. This is described in the second section (\ref{evaln:progs}).


\section{Operators}\label{evaln:ops}
    In order to evaluate the operators, I constructed multiple examples which tested specific input cases/categories and asserted that they functioned as expected in each case. For numeric operators, I tested the following input cases:
    \begin{itemize}
        \item zero and zero -- they form the base case of natural numbers so for
              all recursive operations to be correct, the base case has to be correct
        \item zero and one or one and zero -- since one is the immediate
              successor of zero, there is only the need for one recursive step,
              so if this case works, adding more recursive steps is likely to 
              work
        \item numbers greater than zero and one -- these require multiple 
              recursive steps and so if they work, all numbers should work as
              we then know that recursion works
    \end{itemize}
    \todo{wording?...}
    
    For boolean operators, I tested the possible combinations of \texttt{True} and \texttt{False} for the operator and compared the results with the corresponding truth-table for the corresponding logical operator.
	
    \subsection{The \texttt{Eq} Operator}\label{evaln:ops:eq}
        \lstinputlisting[caption={A C program which requires $0 = 0$}]{"../Idris_Stuff/Examples/Eq/Eq_0_0.c"}
        
        The C program itself may not seem very interesting. However, it is a structurally correct C program. Its purpose is to test the base case of equality between natural numbers: that zero equals zero. This equality assertion would be similar for larger, more complex programs using the annotation.
        
		\idrisinput{"../Idris_Stuff/Examples/Eq/Eq_0_0.idr"}
        
        Transforming the C annotation into \Idris, we get the model detailed above. The model `\texttt{eq\_0\_0} is a \texttt{CLang} consisting of an assertion named `\texttt{eq\_0\_0\_assert}' and nothing more (\texttt{Halt}). This assertion contains two literals \texttt{x} and \texttt{y} both carrying the value 0, their evaluation \texttt{x'} and \texttt{y'} over a given environment \texttt{env}, and a decidable proof \texttt{prf} that the numbers are equal. Using these, we can use \texttt{MkAssertion} to construct an instance of \texttt{Assertion} (Listing \ref{des:assertion}).
        
        \newpage
        
        \begin{code}
Idris> mkCertificate eq_0_0
        \end{code}
		\idrisinput{"../Idris_Stuff/Examples/Eq/Eq_0_0.out"}
        
        Using the \texttt{mkCertificate} function, we construct a certificate based on the \texttt{Assertion} made. We can see that the evaluation of the literals has worked correctly from \texttt{MkEvald (Lit 0) 0}. The final argument to the \texttt{MkAssertion} is a \texttt{Yes Refl}, so the \texttt{Eq} operator worked for zero and zero: It found that they were equal, which is correct.
        \\
        
        \lstinputlisting[caption={A C program which requires $1 = 1$}]{"../Idris_Stuff/Examples/Eq/Eq_1_1.c"}
        
        Again, the actual C program is structurally sound. The assertion tests that 1 equals 1, as one is the immediate successor of zero and hence only requires one recursive step.
        
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_1.idr"}
        
        The resulting \Idris model `\texttt{eq\_1\_1}' contains an assertion that 1 equals 1 (\texttt{Assert eq\_1\_1\_assert}) and nothing more (\texttt{Halt}). This assertion in turn contains the two literals (\texttt{x} and \texttt{y}) both carrying a value of 1 (\texttt{Lit 1}), their evaluation over the given environment (\texttt{x'} and \texttt{y'}), and a decidable proof `\texttt{prf}' that the evaluations are equal.
        
        \begin{code}
Idris> mkCertificate eq_1_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_1.out"}
        
        When passing \texttt{eq\_1\_1} through the \texttt{mkCertificate} function, we see that the evaluations were correct (from \texttt{MkEvald (Lit 1) 1}). The final argument to \texttt{MkAssertion} contains a \texttt{Yes Refl}, so the model has confirmed that $1 = 1$ and as such, that \texttt{Eq} works for 1.
        \\
        
        
        \lstinputlisting[label={evaln:ops:eq-0-1}, caption={A C program which requires $0 = 1$}]{"../Idris_Stuff/Examples/Eq/Eq_0_1.c"}
        
        With $0 = 0$ and $1 = 1$ working, I evaluated that the operator was working correctly for 0 and 1 by testing that $0 = 1$ and $1 = 0$ did not produce a \texttt{Yes Refl}.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_0_1.idr"}
        
        This time, the \Idris model contains two numerically different literals, their evaluation, and a decidable proof of whether they are equal or not.
        
        \begin{code}
Idris> mkCertificate eq_0_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_0_1.out"}
        
        The output from the \texttt{mkCertificate} function over \texttt{eq\_0\_1} shows the literals were evaluated correctly. The proof argument this time contains \texttt{No ZnotS}. This is the built-in version of the proof that zero cannot be the successor of a natural number (Listing \ref{idr:zns}). Given that 0 and 1 were the arguments to \texttt{Eq}, the operator has worked correctly: zero and one are not equal, because zero cannot be the successor of any natural number.
        
        The details of the vice-versa of this, i.e. $1 = 0$ not returning \texttt{Yes Refl}, can be found in Appendix \ref{app:evaln}, Section \ref{app:evaln:ops:eq}. The output from \texttt{mkCertificate} function is slightly unusual, and as such is included here.
        
        \newpage
        
        \begin{code}
Idris> mkCertificate eq_1_0
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_0.out"}
        
        However, the certificate produced is slightly unexpected: it still contains \texttt{ZnotS}, this time combined with a function `\texttt{negEqSym}'. The \texttt{negEqSym} function has the following type:\par
        \texttt{negEqSym : ((a = b) -> Void) -> (b = a) -> Void}\\
        Essentially, the \texttt{negEqSym} proves that if two numbers are not equal, then swapping them around does not change that fact; It proves/states that the negation of equality is \textit{symmetric}. Hence, \texttt{ZnotS} can also be used to prove that $1 = 0$ is false as it is symmetric to proving $0 = 1$ is false. So the \texttt{Eq} operator works correctly when asserting $1 = 0$.
        
        \lstinputlisting[label={evaln:ops:eq-3-3}, caption={A C program which requires $3 = 3$}]{"../Idris_Stuff/Examples/Eq/Eq_3_3.c"}
        
        With both zero and one working, the remaining case is to test that \texttt{Eq} works with multiple recursive calls, i.e. any natural number greater than 1.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_3_3.idr"}
        
        The \texttt{eq\_3\_3} model contains two `3'-literals, their evaluation over the given environment, and a decidable proof that the two evaluations are equal.
        
        \begin{code}
Idris> mkCertificate eq_3_3
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_3_3.out"}
        
        Both evaluations returned 3 as expected and the final argument to \texttt{MkAssertion} is a \texttt{Yes Refl}. Hence, the \texttt{Eq} operator works for numbers greater than 0 and 1; It works in general.
        
        \lstinputlisting[label={evaln:ops:eq-1-3}, caption={A C program which requires $1 = 3$}]{"../Idris_Stuff/Examples/Eq/Eq_1_3.c"}
        
        Finally, to make sure that the operator disproves incorrect equalities for numbers greater than 1, I used the C program above.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_3.idr"}
        
        The model contains the literals `1' and `3', their evaluation over the given environment, and a decidable proof of their equality.
        
        \begin{code}
Idris> mkCertificate eq_1_3
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_3.out"}
        
        Both evaluations match with the literals. The final argument in the \texttt{MkAssertion} argument uses a lambda function and the \texttt{succInjective} function. It has the type:\par
        \texttt{succInjective : (left : Nat) -> (right : Nat) -> (p : S left = S right) -> left = right}\\
        It takes two numbers and proves that if the successor of the left number is reflexive to the successor of the right number, then the numbers themselves must be equal. The argument \texttt{h} is a proof that \texttt{0 = S k}, so if it exists, then we could create a \texttt{Void}. This is a contradiction, so the equality is impossible. Swapping the operands results in almost the same proof.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_3_1.out"}
        
        The only difference between this output is that it uses the \texttt{sym} function. Like with $0 = 1$ and $1 = 0$, this proves that numbers not being equal is symmetrical, so the same proof that they are not equal can be used. These two examples ($1 = 3$ and $3 = 1$), combined with the example in Listing \ref{evaln:ops:eq-3-3}, shows that the \texttt{Eq} function (and by extension, the \texttt{==} operator) works as intended for numbers greater than 0 and 1: if they are equal, then \texttt{Eq} proves it, and if they are not equal, then it correctly produces a proof as to why this is.
    
    \subsection{The \texttt{NEq} Operator}\label{evaln:ops:neq}
        \lstinputlisting[label={evaln:ops:neq-0-1}, caption={A C program requiring $0 \neq 1$}]{"../Idris_Stuff/Examples/NEq/NEq_0_1.c"}
        
        The C program for testing inequality is syntactically correct. Any more complex program which was trying to assert an inequality at some point would use the same annotation and operator.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_0_1.idr"}
        
        The resulting \Idris model contains the literals 0 and 1, their evaluation, and a decidable proof of whether they are equal or not. These are passed as arguments to the \texttt{NEq} function, which is in turn used to construct an \texttt{Assertion} using \texttt{MkAssertion}.
        
        \begin{code}
Idris> mkCertificate neq_0_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_0_1.out"}
        
        Constructing the certificate using the \texttt{mkCertificate} function shows that the last argument to \texttt{NEq} was a \texttt{Yes MkNEqL}, i.e. that the numbers are not equal, specifically because the left number was smaller than the right number, \texttt{MkNEqL}.
        
        \newpage
        
        \begin{code}
Idris> mkCertificate neq_1_0
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_1_0.out"}
        
        Switching the operands around does not change the C program or the model much (see Appendix \ref{app:evaln:ops:neq}, Listing \ref{app:evaln:ops:neq-1-0}). However, the resulting certificate is slightly different: the numbers are still shown to be not equal (the certificate contains a \texttt{Yes}) but this time specifically because the right number was smaller than the left number, \texttt{MkNEqR}.
        For the arguments 0 and 1 the \texttt{NEq} function evaluates correctly that the numbers are not equal, regardless of which side of the operator they are on.
        
        
        \lstinputlisting[label={evaln:ops:neq-0-0}, caption={A C program requiring $0 \neq 0$}]{"../Idris_Stuff/Examples/NEq/NEq_0_0.c"}
        
        Since the program requires 0 to be not equal to 0, the \texttt{NEq} operator should evaluate to false.
        
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_0_0.idr"}
        
        The \Idris model contains two literals, both carrying the value 0, their evaluation, and a decidable proof of whether they are not equal.
        
        \begin{code}
Idris> mkCertificate neq_0_0
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_0_0.out"}
        
        Constructing a certificate shows that the numbers are not unequal (\texttt{No}). The proof that they cannot be unequal is the \texttt{absurd} function, which can be used thanks to the implementation of \texttt{Uninhabited} that we provided in Section \ref{des:neq}, Listing \ref{des:neq-uninh}.
        
        \begin{code}
Idris> mkCertificate neq_1_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_1_1.out"}
        
        Changing the operands to 1, i.e. having a program which requires the immediate successor of 0 to be not equal to itself (Appendix \ref{app:evaln:ops:neq}, Listing \ref{app:evaln:ops:neq-1-1}) results in a similar certificate. The proof that this cannot be is still `\texttt{absurd}', but passed through the \texttt{succNEqImpossible} function (detailed in Listing \ref{des:neq-sneqimp}) which proves that if two numbers are proven to not be unequal, then their successors must also not be unequal.
        \\
        
        With these examples, the \texttt{NEq} operator has been shown to work for for the base case, 0, and its immediate successor, 1. For numbers greater than these, more recursive steps are required.
        
        \newpage
    
        \lstinputlisting[label={evaln:ops:neq-2-5}, caption={A C program requiring $2 \neq 5$}]{"../Idris_Stuff/Examples/NEq/NEq_2_5.c"}
        
        Both 2 and 5 are greater than 0 and 1, and so are not part of the base cases. Since they are higher successors, they should require more recursive steps to show that they are not equal. If it works, then the recursive step works and so any natural number would work.
        
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_2_5.idr"}
        
        Constructing the model, we have the literals 2 and 5, their evaluation over a given environment, and a decidable proof of their inequality. This is passed to the \texttt{NEq} constructor to construct a \texttt{BooleanExpression} which is then passed to the \texttt{MkAssertion} constructor.
        
        \begin{code}
Idris> mkCertificate neq_2_5
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_2_5.out"}
        
        Creating a certificate based on the model shows that the literals have been correctly evaluated and associated. It was also possible to construct a proof that the numbers are not equal (the \texttt{Yes} part of the certificate). As can be seen by the repeated \texttt{MkNEqRec} constructor in the proof, the recursive step works; The left number is smaller (\texttt{MkNEqL}), specifically it is 3 smaller (1 smaller + 2 recursive steps). Swapping the operands and generating the resulting model (Appendix \ref{app:evaln:ops:neq}, Listing \ref{app:evaln:ops:neq-5-2}) should result in a similar result.
        
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_5_2.out"}
        
        Having swapped the order of the operands, the resulting certificate is very similar to the previous one. The literals have swapped order, and the two recursive steps are still there. However, this time the numbers are not equal specifically because right number has been shown to be smaller (\texttt{MkNEqR}). So the \texttt{NEq} operator can show that natural numbers greater than 0 and 1 are not equal. However, we still need to show that it can disprove the inequality between numbers greater than 0 and 1.
        
        \lstinputlisting[caption={A C program requiring $3 \neq 3$}]{"../Idris_Stuff/Examples/NEq/NEq_3_3.c"}
        
        To completely test that the operator works correctly for numbers greater than 0 and 1, the above C program requires that 3 be not equal to itself. This should evaluate to false. If it does, then since 3 requires multiple recursive steps, the operator can prove that two numbers greater than 0 and 1 cannot be unequal.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_3_3.idr"}
        
        The \Idris model has two literals carrying the value 3, their evaluation over a given environment, and a decidable proof of whether they are not equal.
        
        \begin{code}
Idris> mkCertificate neq_3_3
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_3_3.out"}
        
        The resulting certificate shows that the literals were evaluated correctly and that the numbers were shown to not be unequal (the \texttt{No} part in the certificate). Similar to the example for $1 \neq 1$, the proof of this is the \texttt{absurd} function, but this time recursively passed through the \texttt{succNEqImpossible} function three times (due to the number being 3). This shows that the \texttt{NEq} operator works correctly in terms of proving that two natural numbers greater than 0 and 1 cannot be unequal.
        \\
        
        Having shown that the \texttt{NEq} operator works correctly for the base case (0), its immediate successor (1), and natural numbers greater than these, we can conclude that the \texttt{NEq} operator works as intended.
        
    \newpage
    
    \subsection{The \texttt{LTE} Operator}
        \lstinputlisting[label={evaln:ops:lte-0-0}, caption={A C program which requires $0 \leq 0$}]{"../Idris_Stuff/Examples/LTE/LTE_0_0.c"}
        
        This C program captures the essential structure of a program requiring that a property be less than or equal to another. It has a function, two properties compared by the less-than-or-equals (LTE) operator, and the \texttt{assert} annotation.
        
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_0_0.idr"}
        
        Translating this to an \Idris model we get two literals both carrying the value 0, their evaluation over a given environment, and a decidable proof of whether the first is less than or equal to the second. These are passed to the \texttt{LTE} constructor to create a \texttt{BooleanExpression} which is used to create an \texttt{Assertion}.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_0_0.out"}
        
        The resulting certificate shows that the literals were evaluated correctly, and the \texttt{Yes} on the last line shows that we successfully proved that 0 is less than or equal to 0. The \texttt{LTEZero} proof is part of the \Idris prelude and states that zero is the smallest natural number, so any natural number is less than or equal to it. This means that $0 \leq 1$ should be identical (Appendix \ref{app:evaln:ops:lte}, Listing \ref{app:evaln:ops:lte-0-1})
        
        \begin{code}
Idris> mkCertificate lte_0_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_0_1.out"}
        
        The certificate created by asserting $0 \leq 1$ is identical (apart from the `1'-literal) due to it still involving zero on the left-hand side.
        \todo{explain how other LTE-Zero proofs relate}
        
        \lstinputlisting[caption={A C program which requires $1 \leq 1$}]{"../Idris_Stuff/Examples/LTE/LTE_1_1.c"}
        
        Again, the program has the same core structure as any which would assert that one property was LTE to the other. This time both properties are 1 to test that the operator works with the immediate successor of 0.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_1_1.idr"}
        
        The resulting \Idris model has two literals both carrying their the value 1, their evaluation over the given environment, and a decidable proof of the first being LTE to the other.
        
        \begin{code}
Idris> mkCertificate lte_1_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_1_1.out"}
        
        Passing the model through the \texttt{mkCertificate} function, we see that it has successfully evaluated the literals and proven that 1 is LTE than itself, by applying \texttt{LTEZero} using the \texttt{LTESucc} function. It has type:\\
        \texttt{LTESucc : LTE left right -> LTE (S left) (S right)}\\
        The \texttt{LTESucc} function takes a proof that two numbers are LTE to each other, and proves than in that case, so are their successors. So \texttt{Yes (LTESucc LTEZero)} says that since 0 is LTE to any natural number $n$, $(0 + 1)$ is LTE to any natural number $(n + 1)$.
        
        \newpage
        
        \lstinputlisting[caption={A C program requiring $1 \leq 3$}]{"../Idris_Stuff/Examples/LTE/LTE_1_3.c"}
        
        For the case where zero is not on the left-hand side, recursive steps should be required.
        
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_1_3.idr"}
        
        The resulting model this time contains two non-zero literals (1 and 3 respectively), their evaluation over a given environment, and a decidable proof that the left is LTE to the right.
        
        \begin{code}
            Idris> mkCertificate lte_1_3
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_1_3.out"}
        
        The certificate shows that the evaluation successfully proved the comparison to be true. The specifics of the proof show that the left-hand side reached 0 before (or at the same time as) the right-hand side did, so we can apply the \texttt{LTEZero} proof to that side using the \texttt{LTESucc} function (in this case once, to reach 1).
        
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_3_3.out"}
        
        When having a left-hand side greater than 1 (Appendix \ref{app:evaln:ops:lte}, Listing \ref{app:evaln:ops:lte-3-3}) , we can more clearly see the recursive step. Here, the \texttt{LTESucc} function is applied three times to the \texttt{LTEZero} proof, thereby proving that the left-hand side `3' reached 0 before, or at the same time as, the right-hand side and therefore it is LTE to the right-hand side.
        
        \lstinputlisting[caption={A C program requiring $1 \leq 0$}]{"../Idris_Stuff/Examples/LTE/LTE_1_0.c"}
        
        To test that the \texttt{LTE} operator can prove that numbers cannot be LTE to each other, we first test with 0 and its immediate successor (1), as they should not require any recursive steps.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_1_0.idr"}
        
        The resulting \Idris model has the literals 1 and 0 respectively, their evaluation, and a decidable proof of whether the left is LTE to the right (i.e. $1 \leq 0$).
        
        \begin{code}
Idris> mkCertificate lte_1_0
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_1_0.out"}
        
        Generating a certificate from the model, from the `\texttt{No}' we can see that it successfully evaluated that 1 is not LTE than 0. The exact proof, \texttt{succNotLTEzero}, has the following type:\\
        \texttt{succNotLTEzero : Not (LTE (S m) 0)}\\
        It states that no successor of any natural number \texttt{m} could be LTE to zero. So the \texttt{LTE} operator successfully works for 1 and its immediate predecessor 0, which is also the base case of natural numbers.
        
        \newpage
        
        \lstinputlisting[caption={A C program requiring $3 \leq 1$}]{"../Idris_Stuff/Examples/LTE/LTE_3_1.c"}
        
        Changing the false expression such that both numbers are greater than 0, we should get more recursive steps to prove that they cannot be LTE to each other.
        
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_3_1.idr"}
        
        The \Idris model has the literals 3 and 1 instead of 1 and 0 respectively. Apart from that, it is identical to the previous.
        
        \begin{code}
Idris> mkCertificate lte_3_1
        \end{code}
        \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_3_1.out"}
        
        The certificate makes use of the same \texttt{succNotLTEzero} proof to prove that 3 cannot be LTE to 1. The recursive step is the \texttt{fromLteSucc} function, which is passed the argument \texttt{x1} from a lambda. The \texttt{fromLteSucc} function has the following type:\\
        \texttt{fromLteSucc : LTE (S m) (S n) -> LTE m n}\\
        It takes a proof that the successors of two numbers are LTE to each other and concludes that in that case, so are their predecessors. If it was possible to construct this proof for 2 and 0 (the predecessors to 3 and 1), then \texttt{succNotLTEzero} states that it cannot exist. So it is never possible that 3 is LTE to 1.
        \\
        
        With these examples, covering the base case (0), its immediate successor (1), and numbers larger than this (where recursion is used), we have showed that the \texttt{LTE} operator works as intended.
        
        \todo{put the other ops in appendix}
        \todo{explain why the others are in an appendix}
    
    \subsection{The \texttt{Or} Operator}\label{evaln:ops:or}
        Since `or' operates on booleans, we needed two \texttt{BooleanExpression}s: one \texttt{True} and one \texttt{False} . We used $1 = 1$ for \texttt{True} and $0 = 1$ for \texttt{False}
        
        \idrisinput[label={evaln:ops:or:true}, caption={A boolean expression which is true}]{"../Idris_Stuff/Examples/True.idr"}
        
        The `\texttt{b\_true}' function is a boolean expression which evaluates to \texttt{True} over an environment. In this case, $1 = 1$.
        
        \idrisinput[label={evaln:ops:or:false}, caption={A boolean expression which is false}]{"../Idris_Stuff/Examples/False.idr"}
        
        The `\texttt{b\_false}' function is a boolean expression which evaluates to \texttt{False} over an environment. In this case, $0 = 1$.
        \\
    
        The truth-table for logical `or' is:
        \begin{center}
            \begin{tabular}{c | c}
                a b & a $\lor$ b \\
                \hline
                T T & T \\
                T F & T \\
                F T & T \\
                F F & F \\
            \end{tabular}
        \end{center}
    
        \lstinputlisting[caption={A C program where both `or' operands happen to be true}]{"../Idris_Stuff/Examples/Or/Or_t_t.c"}
        
        It is possible that a program would at some point assert that at least one of two properties held. And that both properties happened to hold. Such a program would have a similar assertion to the above.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/Or/Or_t_t.idr"}
        
        The resulting \Idris model contains two boolean expressions which should evaluate to \texttt{True} (Listing \ref{evaln:ops:or:true}), their evaluation over a given environment, and a decidable proof of whether the `or' expression evaluates to true.
        
        \idrisinput{"../Idris_Stuff/Examples/Or/Or_t_t.out"}
        
        When generating the certificate, we can see that the true boolean expression has been filled in where the \texttt{b\_true} used to be, and that the expressions held true: both \texttt{MkBevald}s have \texttt{True} at the end. The final argument to the \texttt{Or} function is a \texttt{Yes MkOr}, i.e. the operator has evaluated to \texttt{True} due to both arguments being true.
    
        \lstinputlisting[label={evaln:ops:or-t-f}, caption={A C program where the left `or' operand happens to be true}]{"../Idris_Stuff/Examples/Or/Or_t_f.c"}
        
        Another possibility is that one of the properties could be true and the other false. This should still evaluate to true.
        
        \idrisinput{"../Idris_Stuff/Examples/Or/Or_t_f.idr"}
        
        The resulting model now contains both a true and a false boolean expression (from Listing \ref{evaln:ops:or:true} and \ref{evaln:ops:or:false} respectively). Apart from that, it is unchanged.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/Or/Or_t_f.out"}
        
        From the certificate we can see that the boolean expressions were correctly evaluated: the first evaluated to \texttt{True} and the second to \texttt{False}. The final line before the type declaration is \texttt{Yes MkOrL}, so the operator has correctly showed that the expression evaluates to \texttt{True}: the left argument held true.
        
        \idrisinput{"../Idris_Stuff/Examples/Or/Or_f_t.out"}
        
        Swapping the true and false boolean expressions (Appendix \ref{app:evaln:ops:or}, Listing \ref{app:evaln:ops:or-f-t}), we get the above certificate. Again, the boolean expressions have been evaluated correctly: the first is \texttt{False} and the second is \texttt{True}. This time, the proof for `or' is a \texttt{Yes MkOrR}, so the operator functioned correctly: The `or' expression evaluates to \texttt{True} because the right argument held true.
        
        \lstinputlisting[caption={A C program where both `or' operands happen to be false}]{"../Idris_Stuff/Examples/Or/Or_f_f.c"}
        
        Finally, it is possible that both properties did not hold. In this case, the operator should evaluate to \texttt{False}, i.e it should be impossible to construct one of the previous proofs.
        
        \idrisinput{"../Idris_Stuff/Examples/Or/Or_f_f.idr"}
        
        The corresponding \Idris model's boolean expressions are both the ones that evaluate to \texttt{False} (Listing \ref{evaln:ops:or:false}). Apart from that, it is identical to the previous ones.
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/Or/Or_f_f.out"}
        
        The resulting certificate shows that both boolean expressions correctly evaluated to \texttt{False}. Furthermore, the final part is a `\texttt{No absurd}' which shows that the operator correctly determined that the `or'-expression cannot be true, using the \texttt{Uninhabited} implementations for \texttt{TyOr} (Listing \ref{des:or-uninh}) to prove this.
        \\
        
        All the cases evaluate to the value predicted from the truth-table. As such, we can conclude that the \texttt{Or} operator works correctly.
    
    \subsection{The \texttt{Not} Operator}\label{evaln:ops:not}
        The \texttt{True} and \texttt{False} boolean expressions used to evaluate \texttt{Not} are the same as in \texttt{Or}, i.e. Listings \ref{evaln:ops:or:true} and \ref{evaln:ops:or:false}.
        \\
        
        The truth-table for logical negation is:
        \begin{center}
            \begin{tabular}{c | c}
                p & $\lnot$p \\
                \hline
                F & T \\
                T & F \\
            \end{tabular}
        \end{center}
        
        \newpage
        
        \lstinputlisting[caption={A C program where the property that must not hold is false}]{"../Idris_Stuff/Examples/Not/Not_false.c"}
        
        If a program was trying to assert that a property did not hold, then it would be using the logical `not' operator. In the desired case, this means the property itself evaluates to false. This situation would be similar to the one in the program above.
        
        \idrisinput{"../Idris_Stuff/Examples/Not/Not_false.idr"}
        
        The corresponding \Idris model only has one boolean expression which should evaluate to \texttt{False} (Listing \ref{evaln:ops:or:false}), its evaluation over a given environment, and a proof of whether its negation is true.
        
        \idrisinput{"../Idris_Stuff/Examples/Not/Not_false.out"}
        
        Making the certificate, we can see that the boolean expression was evaluated to \texttt{False} (in the \texttt{BEvald}) and that the final argument is a \texttt{Yes MkBNot}. This shows that the operator returns \texttt{True} when the input is \texttt{False}, as it should.
        
        \lstinputlisting[caption={A C program where the property that must not hold is true}]{"../Idris_Stuff/Examples/Not/Not_true.c"}
        
        In the undesired case, the property that must not hold does. This means that the expression should evaluate to \texttt{False}. This situation would be similar to the one in the program above.
        
        \idrisinput{"../Idris_Stuff/Examples/Not/Not_true.idr"}
        
        The resulting \Idris model again only has one boolean expression. However, this time it should evaluate to \texttt{True} (Listing \ref{evaln:ops:or:true}). Apart from this, the model is identical to the previous.
        
        \idrisinput{"../Idris_Stuff/Examples/Not/Not_true.out"}
        
        Looking at the certificate produced, we can see that the boolean expression correctly evaluated to \texttt{True} and that the final argument is a `\texttt{No absurd}'. This means that the operator has proved that the expression cannot evaluate to \texttt{True}, using the \texttt{Uninhabited} implementation of \texttt{Not} (Listing \ref{des:not-uninh}), and as such, the operator functions correctly when negating a \texttt{True} expression.
        \\
        
        The results from the operator correspond to the truth-table for boolean negation. Therefore, the \texttt{Not} operator works as intended.
        \\
        
        With a set of operators verified to be correct, I constructed and modelled some more complex examples.

\newpage


\section{Simple Programs}\label{evaln:progs}
    \subsection{Loop accumulation}
        \lstinputlisting[caption={A C program whose loop has a timing requirement.}]{"../Idris_Stuff/Examples/Advanced/Loop.c"}
        
        \idrisinput{"../Idris_Stuff/Examples/Advanced/Loop.idr"}
        \todo{fix the out-of-bounds}
        
        \newpage
        
        \idrisinput{"../Idris_Stuff/Examples/Advanced/Loop.out"}
