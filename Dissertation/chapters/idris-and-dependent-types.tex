This chapter aims to give the reader enough of an overview of \Idris and dependent types to be able to understand the work done in the later chapters. A complete explanation of \Idris is beyond the scope of this chapter. This chapter borrows a lot of examples and explanations from the \Idris book (``Type-Driven Development with Idris'') \cite{brady_2017}.

\section{Types}

    \begin{code}[caption={In \Idris, the type of a function is specified using `\texttt{:}'}]
        anInt : Int
        anInt = 10
        
        aString : String
        aString = "foo"
        
        aBool : Bool
        aBool = False
    \end{code}

    Types classify values. In programming, we often come across types like \texttt{Int}, \texttt{String}, or \texttt{Bool}, which could be values like \texttt{10}, \texttt{"foo"}, or \texttt{False} respectively.

    \newpage

    \begin{code}[caption={Mismatching types}, escapeinside={(*}{*)}]
        aString : String
        aString = 10
        
        
        -- Compiler error --
        
          |
        2 | aString = 10
          |           ~~
        When checking right hand side of aString with expected type
        String
        
        String is not a numeric type
    \end{code}
    Types in \Idris are checked at compile time, meaning that if the types of the functions in a program do not match (for example, passing an \texttt{Int} where a \texttt{String} is required) then the program will not compile and the compiler will give a type-error.
    
    \begin{code}[caption={Values are not automatically cast}]
anInt : Int
anInt = 10

half : Double -> Double
half x = x / 2


> half anInt
(input):1:1-10:When checking an application of function Main.half:
        Type mismatch between
                Int (Type of anInt)
        and
                Double (Expected type)
    \end{code}
    
    \Idris is strongly typed, so the compiler will not automatically cast values or parameters. This means you cannot pass an \texttt{Int} to a function which requires a \texttt{Double} and have it automatically work, because \texttt{Int} is a different type, a different `category' from \texttt{Double}.
    
\section{Type Variables and Dependent Types}
    A different example of a type is a list of values. In languages like Java or Python, lists are parametrised over a type.
    \begin{code}[caption={The types of different lists in \Idris}]
        [1, 2, 3, 4, 5] : List Integer
        
        ["a", "b", "c"] : List String
        
        [True, False]   : List Bool
    \end{code}
    In \Idris this is still the case. You can have lists of \texttt{String}, lists of \texttt{Int}, or lists of \texttt{Bool} and these are different types. In general, you can have any \texttt{List elem} where \texttt{elem} is a type variable representing the type of the elements of the list. \Idris provides an even more specific type of lists: \texttt{Vect}
    \begin{code}[caption={Example \texttt{Vect} types}]
        [1, 2, 3, 4, 5] : Vect 5 Int
        
        ["a", "b", "c"] : Vect 3 String
        
        [True, False]   : Vect 2 Bool
    \end{code}
    A \texttt{Vect}, short for ``vector'', is a list with a specific length. In general, you can have any \texttt{Vect n elem}. Here, \texttt{elem} is the same as in \texttt{List}, and \texttt{n} is the length of the list. Since the value of \texttt{n} \textit{depends} on the number of elements in the list, we refer to types like \texttt{Vect n elem} as dependent because its precise type depends on other values. Another example of a dependent type is \texttt{Matrix m n elem}, i.e. a matrix of \texttt{m} rows and \texttt{n} columns, with elements of type \texttt{elem}.
    \[
    \begin{pmatrix}
    1 & 2 \\
    3 & 4 \\
    5 & 6 \\
    \end{pmatrix}
    \hspace{50pt}
    \begin{pmatrix}
    ``1" & ``2" & ``3" \\
    ``4" & ``5" & ``6" \\
    \end{pmatrix}
    \]
    Here, the first matrix would have type \texttt{Matrix 3 2 Int} and the second matrix would have type \texttt{Matrix 2 3 String}. In \Idris we can also define our own data types. This is useful when we want to capture an aspect of the program we are writing which is likely not pre-defined in the \Idris prelude.

\section{Data Types}
% TODO: data types

\section{Functions}
% TODO: functions in Idris
% TODO: purity

\section{Natural Numbers}
    Natural numbers in \Idris are implemented as Peano numbers \cite{brady_2013}. This means that the natural numbers $\mathbb{N}$ are defined based on the constant 0 (\idrisinline{Z} in Idris) and the \textit{successor function} \idrisinline{S}. From these two, all the naturals can be constructed:
    \begin{tabular}{r l}
        \idrisinline{Z} & $\mapsto 0$ \\ 
        \idrisinline{S Z} & $\mapsto 1$ \\ 
        \idrisinline{S (S Z)} & $\mapsto 2$ \\
        etc & \\
        \vdots & \\
    \end{tabular}
    \par
    The benefit of this is that it allows us to pattern match on numbers. This helps in terms of decidability.

\section{Decidability}\label{idris:dec}
	The reader may be familiar with Haskell's \texttt{Maybe} monad, which allows a function to return something that may not be there, e.g. a specific substring of a string. In \Idris, the \texttt{Dec} type allows for a stronger guarantee: either something is there, or there is a proof that it is impossible to create that thing.
	\begin{code}[caption={\texttt{Dec} as defined in the \Idris prelude \cite{brady_2017}}]
        data Dec : (prop : Type) -> Type where
             Yes : (prf : prop) -> Dec prop
             No  : (contra : prop -> Void) -> Dec prop
	\end{code}
    Here, \texttt{prf} is a proof that \texttt{prop} holds. And \texttt{contra} is a proof that the value can never exist. The latter is done by having a function which returns \texttt{Void} given \texttt{prop}. \texttt{Void} is a data type with no constructors, i.e. if it is ever possible to return a \texttt{Void}, then it must be impossible to construct one of the arguments to the function (in this case \texttt{prop}). An example use-case of this is proving that two natural numbers are equal:
	\begin{code}[caption={Proving the equality between natural numbers \cite{brady_2017}},label={lst:decEq}]
    -- a proof that zero cannot be the successor of a natural number
    zeroNotSuc : (0 = S k) -> Void
    zeroNotSuc Refl impossible
    
    -- a proof that the successor of a natural number cannot be zero
    sucNotZero : (S k = 0) -> Void
    sucNotZero Refl impossible
    
    -- given a proof that two numbers ARE NOT equal and a proof that
    -- their successors ARE equal, return the empty type, i.e. a
    -- proof by contradiction
    noRec : (contra : (k = j) -> Void) -> (S k = S j) -> Void
    noRec contra Refl = contra Refl

    -- decidably describe whether two numbers are equal
    decEq : (a : Nat) -> (b : Nat) -> Dec (a = b)
    decEq Z Z = Yes Refl
    decEq Z (S j) = No zeroNotSuc
    decEq (S k) Z = No sucNotZero
    decEq (S k) (S j) = case decEq k j of
                            Yes prf => Yes (cong prf)
                            No contra => No (noRec contra)
	\end{code}
    This is somewhat useful on its own, but the best bit is that any function which uses the above check, or any other \texttt{Dec}, has both an answer as to whether the check was valid or not \textit{and} a proof that it is or a proof that it is impossible.

\section{Proofs}
    Proofs in \Idris rely on the type-checker and constructors. The reason \texttt{Refl} is a proof for equality is that it is defined as follows:
    \begin{code}[caption={Reflexivity as defined in the \Idris prelude \cite{brady_2017}}]
        data (=) : a -> b -> Type where
            Refl : x = x
    \end{code}
    The only constructor for \texttt{(=)} is \texttt{Refl} and \texttt{Refl} can only be constructed when the arguments are equal. Therefore, if a program using \texttt{Dec (t1 = t2)} type-checks, the only way that the program can return a \texttt{Yes Refl} is if the arguments to the function were truly equal. Similarly, the only way that the program could return a \texttt{No contra} is if there is no possible way that a \texttt{Refl} could be constructed; No possible way the arguments could be equal. This is a very common thing in proofs, and as such \Idris provides a number of things to help describe this.
    \\\par
    
    % TODO: Rewrite this - Alex didn't understand
    For counter-proofs, we have already seen the \texttt{Void} type (Section \ref{idris:dec}). \texttt{Void} is interesting because it is impossible to construct, meaning that given an instance of it we can do anything (e.g. prove \texttt{2 = 3}). The \texttt{void} function in \Idris captures this. It is defined as:
    \begin{code}
        void : Void -> a
    \end{code}
    Essentially, \texttt{Void} and \texttt{void} captures the absurdity of a contradiction. If we accept the contradiction to hold, we can then prove anything we want; We can construct any type we want. The \texttt{Uninhabited} interface allows us to specify instances which have no constructors and is defined as follows:
    \begin{code}[caption={The \texttt{Uninhabited} interface \cite{brady_2017}}]
        interface Uninhabited t where
            uninhabited : t -> Void
    \end{code}
    For example, we could define \texttt{Uninhabited} for \texttt{2 = 3}:
    \begin{code}
        implementation Uninhabited (2 = 3) where
            uninhabited Refl impossible
    \end{code}
    The \texttt{impossible} keyword specifies a case which would not type check and tells the \Idris type checker that it \textit{must} not type check. If the case specified as \texttt{impossible} could type-check, i.e. there \textit{is} a way to construct it, \Idris will print an error message and the program will not compile. Therefore, if a program using \texttt{impossible} compiles, we can be sure that it is truly not possible to construct something of that type.
    % TODO: `impossible` example
    This is in turn used to define the \texttt{absurd} function in the Prelude:
    \begin{code}[caption={The \texttt{absurd} function  \cite{brady_2017}}]
        absurd : Uninhabited t => (h : t) -> a
        absurd h = void (uninhabited h)
    \end{code}
    With \texttt{absurd} we have described exactly that: an absurdity. Hence, any constructors specified in an \texttt{Uninhabited} implementation allows a function to call \texttt{absurd}, thereby covering all cases and describing which of them cannot happen. Or rather, describing \textit{precisely which} can happen.
    
    % TODO: explain Uninhabited, absurd
