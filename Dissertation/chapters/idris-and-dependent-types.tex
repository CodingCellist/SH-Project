This chapter aims to give the reader enough of an overview of \Idris and dependent types to be able to understand the work done in the later chapters. A complete explanation of \Idris is beyond the scope of this chapter. This chapter borrows a lot of examples and explanations from the \Idris book (``Type-Driven Development with Idris'') \cite{brady_2017}.

\section{Types and Dependent Types}
% TODO: types and dependent types

\section{Data Types}
% TODO: data types

\section{Functions}
% TODO: purity
% TODO: functions in Idris

\section{Natural Numbers}
    Natural numbers in \Idris are implemented as Peano numbers \cite{brady_2013}. This means that the natural numbers $\mathbb{N}$ are defined based on the constant 0 (\idrisinline{Z} in Idris) and the \textit{successor function} \idrisinline{S}. From these two, all the naturals can be constructed:
    \begin{tabular}{r l}
        \idrisinline{Z} & $\mapsto 0$ \\ 
        \idrisinline{S Z} & $\mapsto 1$ \\ 
        \idrisinline{S (S Z)} & $\mapsto 2$ \\
        etc & \\
        \vdots & \\
    \end{tabular}
    \par
    The benefit of this is that it allows us to pattern match on numbers. This helps in terms of decidability.

\section{Decidability}\label{idris:dec}
	The reader may be familiar with Haskell's \texttt{Maybe} monad, which allows a function to return something that may not be there, e.g. a specific substring of a string. In \Idris, the \texttt{Dec} type allows for a stronger guarantee: either something is there, or there is a proof that it is impossible to create that thing.
	\begin{code}[caption={\texttt{Dec} as defined in the \Idris prelude \cite{brady_2017}}]
        data Dec : (prop : Type) -> Type where
             Yes : (prf : prop) -> Dec prop
             No  : (contra : prop -> Void) -> Dec prop
	\end{code}
    Here, \texttt{prf} is a proof that \texttt{prop} holds. And \texttt{contra} is a proof that the value can never exist. The latter is done by having a function which returns \texttt{Void} given \texttt{prop}. \texttt{Void} is a data type with no constructors, i.e. if it is ever possible to return a \texttt{Void}, then it must be impossible to construct one of the arguments to the function (in this case \texttt{prop}). An example use-case of this is proving that two natural numbers are equal:
	\begin{code}[caption={Proving the equality between natural numbers \cite{brady_2017}},label={lst:decEq}]
    -- a proof that zero cannot be the successor of a natural number
    zeroNotSuc : (0 = S k) -> Void
    zeroNotSuc Refl impossible
    
    -- a proof that the successor of a natural number cannot be zero
    sucNotZero : (S k = 0) -> Void
    sucNotZero Refl impossible
    
    -- given a proof that two numbers ARE NOT equal and a proof that
    -- their successors ARE equal, return the empty type, i.e. a
    -- proof by contradiction
    noRec : (contra : (k = j) -> Void) -> (S k = S j) -> Void
    noRec contra Refl = contra Refl

    -- decidably describe whether two numbers are equal
    decEq : (a : Nat) -> (b : Nat) -> Dec (a = b)
    decEq Z Z = Yes Refl
    decEq Z (S j) = No zeroNotSuc
    decEq (S k) Z = No sucNotZero
    decEq (S k) (S j) = case decEq k j of
                            Yes prf => Yes (cong prf)
                            No contra => No (noRec contra)
	\end{code}
    This is somewhat useful on its own, but the best bit is that any function which uses the above check, or any other \texttt{Dec}, has both an answer as to whether the check was valid or not \textit{and} a proof that it is or a proof that it is impossible.

\section{Proofs}
    Proofs in \Idris rely on the type-checker and constructors. The reason \texttt{Refl} is a proof for equality is that it is defined as follows:
    \begin{code}[caption={Reflexivity as defined in the \Idris prelude \cite{brady_2017}}]
        data (=) : a -> b -> Type where
            Refl : x = x
    \end{code}
    The only constructor for \texttt{(=)} is \texttt{Refl} and \texttt{Refl} can only be constructed when the arguments are equal. Therefore, if a program using \texttt{Dec (t1 = t2)} type-checks, the only way that the program can return a \texttt{Yes Refl} is if the arguments to the function were truly equal. Similarly, the only way that the program could return a \texttt{No contra} is if there is no possible way that a \texttt{Refl} could be constructed; No possible way the arguments could be equal. This is a very common thing in proofs, and as such \Idris provides a number of things to help describe this.
    \\\par
    
    % TODO: Rewrite this - Alex didn't understand
    For counter-proofs, we have already seen the \texttt{Void} type (Section \ref{idris:dec}). \texttt{Void} is interesting because it is impossible to construct, meaning that given an instance of it we can do anything (e.g. prove \texttt{2 = 3}). The \texttt{void} function in \Idris captures this. It is defined as:
    \begin{code}
        void : Void -> a
    \end{code}
    Essentially, \texttt{Void} and \texttt{void} captures the absurdity of a contradiction. If we accept the contradiction to hold, we can then prove anything we want; We can construct any type we want. The \texttt{Uninhabited} interface allows us to specify instances which have no constructors and is defined as follows:
    \begin{code}[caption={The \texttt{Uninhabited} interface \cite{brady_2017}}]
        interface Uninhabited t where
            uninhabited : t -> Void
    \end{code}
    For example, we could define \texttt{Uninhabited} for \texttt{2 = 3}:
    \begin{code}
        implementation Uninhabited (2 = 3) where
            uninhabited Refl impossible
    \end{code}
    The \texttt{impossible} keyword specifies a case which would not type check and tells the \Idris type checker that it \textit{must} not type check. If the case specified as \texttt{impossible} could type-check, i.e. there \textit{is} a way to construct it, \Idris will print an error message and the program will not compile. Therefore, if a program using \texttt{impossible} compiles, we can be sure that it is truly not possible to construct something of that type.
    % TODO: `impossible` example
    This is in turn used to define the \texttt{absurd} function in the Prelude:
    \begin{code}[caption={The \texttt{absurd} function  \cite{brady_2017}}]
        absurd : Uninhabited t => (h : t) -> a
        absurd h = void (uninhabited h)
    \end{code}
    With \texttt{absurd} we have described exactly that: an absurdity. Hence, any constructors specified in an \texttt{Uninhabited} implementation allows a function to call \texttt{absurd}, thereby covering all cases and describing which of them cannot happen. Or rather, describing \textit{precisely which} can happen.
    
    % TODO: explain Uninhabited, absurd
