\section{Natural Numbers}
    Natural numbers in \Idris are implemented as Peano numbers \cite{brady_2013}. This means that the natural numbers $\mathbb{N}$ are defined based on the constant 0 (\idrisinline{Z} in Idris) and the \textit{successor function} \idrisinline{S}. From these two, all the naturals can be constructed:
    \begin{tabular}{r l}
        \idrisinline{Z} & $\mapsto 0$ \\ 
        \idrisinline{S Z} & $\mapsto 1$ \\ 
        \idrisinline{S (S Z)} & $\mapsto 2$ \\
        etc & \\
        \vdots & \\
    \end{tabular}
    \par
    The benefit of this is that it allows us to pattern match on numbers. This helps in terms of decidability.

\section{Decidability}
	The reader may be familiar with Haskell's \texttt{Maybe} monad, which allows a function to return something that may not be there, e.g. a specific substring of a string. In \Idris, the \texttt{Dec} type allows for a stronger guarantee: either something is there, or there is a proof that it is impossible to create that thing.
	\begin{lstlisting}[caption={\texttt{Dec} as defined in the \Idris prelude \cite{brady_2017}}]
        data Dec : (prop : Type) -> Type where
             Yes : (prf : prop) -> Dec prop
             No  : (contra : prop -> Void) -> Dec prop
	\end{lstlisting}
    Here, \texttt{prf} is a proof that \texttt{prop} holds. And \texttt{contra} is a proof that the value can never exist. The latter is done by having a function which returns \texttt{Void} given \texttt{prop}. \texttt{Void} is a data type with no constructors, i.e. if it is ever possible to return a \texttt{Void}, then it must be impossible to construct one of the arguments to the function (in this case \texttt{prop}). An example use-case of this is proving that two natural numbers are equal:
	\begin{lstlisting}[caption={Proving the equality between natural numbers \cite{brady_2017}},label={lst:decEq}]
    -- a proof that zero cannot be the successor of a natural number
    zeroNotSuc : (0 = S k) -> Void
    zeroNotSuc Refl impossible
    
    -- a proof that the successor of a natural number cannot be zero
    sucNotZero : (S k = 0) -> Void
    sucNotZero Refl impossible
    
    -- given a proof that two numbers ARE NOT equal and a proof that
    -- their successors ARE equal, return the empty type, i.e. a
    -- proof by contradiction
    noRec : (contra : (k = j) -> Void) -> (S k = S j) -> Void
    noRec contra Refl = contra Refl

    -- decidably describe whether two numbers are equal
    decEq : (a : Nat) -> (b : Nat) -> Dec (a = b)
    decEq Z Z = Yes Refl
    decEq Z (S j) = No zeroNotSuc
    decEq (S k) Z = No sucNotZero
    decEq (S k) (S j) = case decEq k j of
                            Yes prf => Yes (cong prf)
                            No contra => No (noRec contra)
	\end{lstlisting}
    This is somewhat useful on its own, but the best bit is that any function which uses the above check, or any other \texttt{Dec}, has both an answer as to whether the check was valid or not \textit{and} a proof that it is or a proof that it is impossible.

\section{Proofs}
    Proofs in \Idris rely on the type-checker and constructors. The reason \texttt{Refl} is a proof for equality is that it is defined as follows:
    \begin{lstlisting}[caption={Reflexivity as defined in the \Idris prelude \cite{brady_2017}}]
        data (=) : a -> b -> Type where
            Refl : x = x
    \end{lstlisting}
    The only constructor for \texttt{(=)} is \texttt{Refl} and \texttt{Refl} can only be constructed when the arguments are equal. Therefore, if a program using \texttt{=} type-checks, the only way that the program can return a \texttt{Yes Refl} is if the arguments to the function were truly equal. Similarly, the only way that the program could return a \texttt{No contra} is if there is a constructible reason as to why the arguments are different.
