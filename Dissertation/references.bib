@inproceedings{Brady:2011:ISP:1929529.1929536,
    author      = {Brady, Edwin},
    title       = {IDRIS ---: Systems Programming Meets Full Dependent Types},
    booktitle   = {Proceedings of the 5th ACM Workshop on Programming Languages Meets Program Verification},
    series      = {PLPV '11},
    year        = {2011},
    isbn        = {978-1-4503-0487-0},
    location    = {Austin, Texas, USA},
    pages       = {43--54},
    numpages    = {12},
    url         = {http://doi.acm.org/10.1145/1929529.1929536},
    doi         = {10.1145/1929529.1929536},
    acmid       = {1929536},
    publisher   = {ACM},
    address     = {New York, NY, USA},
    keywords    = {data description, dependent types}
}

@article{brady2015embedded,
    title       = {Embedded Domain Specific Languages in Idris},
    author      = {Brady, Edwin},
    year        = {2015}
}

@inproceedings{10.1007/978-3-642-27694-1_18,
    author      = {Brady, Edwin and Hammond, Kevin},
    editor      = {Russo, Claudio and Zhou, Neng-Fa},
    title       = {Resource-Safe Systems Programming with Embedded Domain Specific Languages},
    booktitle   = {Practical Aspects of Declarative Languages},
    year        = {2012},
    publisher   = {Springer Berlin Heidelberg},
    address     = {Berlin, Heidelberg},
    pages       = {242--257},
    abstract    = {We introduce a new overloading notation that facilitates programming, modularity and reuse in Embedded Domain Specific Languages (EDSLs), and use it to reason about safe resource usage and state management. We separate the structural language constructs from our primitive operations, and show how precisely-typed functions can be lifted into the EDSL. In this way, we implement a generic framework for constructing state-aware EDSLs for systems programming.},
    isbn        = {978-3-642-27694-1},
    doi			= {10.1007/978-3-642-27694-1_18}
}

@inproceedings{10.1007/978-3-540-39815-8_3,
    author      = {Hammond, Kevin and Michaelson, Greg},
    editor      = {Pfenning, Frank and Smaragdakis, Yannis},
    title       = {Hume: A Domain-Specific Language for Real-Time Embedded Systems},
    booktitle   = {Generative Programming and Component Engineering},
    year        = {2003},
    publisher   = {Springer Berlin Heidelberg},
    address     = {Berlin, Heidelberg},
    pages       = {37--56},
    abstract    = {This paper describes Hume: a novel domain-specific language whose purpose is to explore the expressibility/costability spectrum in resource-constrained systems, such as real-time embedded or control systems. Hume provides a number of high level features including higher-order functions, polymorphic types, arbitrary but sized user-defined data structures, asynchronous processes, lightweight exception handling, automatic memory management and domain-specific metaprogramming features, whilst seeking to guarantee strong space/time behaviour and maintaining overall determinacy.},
    isbn        = {978-3-540-39815-8},
    doi			= {10.1007/978-3-540-39815-8_3}
}

@inproceedings{5558637,
    author      = {E. {Axelsson} and K. {Claessen} and G. {Dévai} and Z. {Horváth} and K. {Keijzer} and B. {Lyckegård} and A. {Persson} and M. {Sheeran} and J. {Svenningsson} and A. {Vajdax}},
    booktitle   = {Eighth ACM/IEEE International Conference on Formal Methods and Models for Codesign (MEMOCODE 2010)},
    title       = {Feldspar: A domain specific language for digital signal processing algorithms},
    year        = {2010},
    volume      = {},
    number      = {},
    pages       = {169-178},
    keywords    = {data flow analysis;functional languages;machine oriented languages;optimisation;signal processing;Feldspar;domain specific language;digital signal processing;functional language;high-level dataflow;high-level optimization;vector fusion;machine-oriented languages;Indexes;Digital signal processing;Generators;Optimization;Kernel;Arrays;DSL},
    doi         = {10.1109/MEMCOD.2010.5558637},
    ISSN        = {},
    month       = {July}
}

@inproceedings{5158855,
    author      = {S. {Bhatti} and E. {Brady} and K. {Hammond} and J. {McKinna}},
    booktitle   = {2009 29th IEEE International Conference on Distributed Computing Systems Workshops},
    title       = {Domain Specific Languages (DSLs) for Network Protocols (Position Paper)},
    year        = {2009},
    volume      = {},
    number      = {},
    pages       = {208-213},
    keywords    = {program testing;protocols;specification languages;domain specific languages;network protocols;next generation network architectures;inline testing;programming language design;correct-by-construction design;programming language support;Domain specific languages;DSL;Routing protocols;Next generation networking;System testing;Mobile communication;Functional programming;Computer languages;Wireless application protocol;Sockets},
    doi         = {10.1109/ICDCSW.2009.64},
    ISSN        = {1545-0678},
    month       = {June}
}

@article{brady2010correct,
    title       = {Correct-by-construction concurrency: Using dependent types to verify implementations of effectful resource usage protocols},
    author      = {Brady, Edwin and Hammond, Kevin},
    journal     = {Fundamenta Informaticae},
    volume      = {102},
    number      = {2},
    pages       = {145--176},
    year        = {2010},
    publisher   = {IOS Press}
}


@inproceedings{10.1007/3-540-45350-4_5,
    author      = {Elliott, Conal and Finne, Sigbj{\o}rn and de Moor, Oege},
    editor      = {Taha, Walid},
    title       = {Compiling Embedded Languages},
    booktitle   = {Semantics, Applications, and Implementation of Program Generation},
    year        = {2000},
    publisher   = {Springer Berlin Heidelberg},
    address     = {Berlin, Heidelberg},
    pages       = {9--26},
    abstract    = {Functional languages are particularly well-suited to the im- plementation of interpreters for domain-specific embedded languages (DSELs). We describe an implemented technique for producing optimiz- ing compilers for DSELs, based on Kamin's idea of DSELs for program generation. The technique uses a data type of syntax for basic types, a set of smart constructors that perform rewriting over those types, some code motion transformations, and a back-end code generator. Domain- specific optimization results from chains of rewrites on basic types. New DSELs are defined directly in terms of the basic syntactic types, plus host language functions and tuples. This definition style makes compil- ers easy to write and, in fact, almost identical to the simplest embedded interpreters. We illustrate this technique with a language Pan for the computationally intensive domain of image synthesis and manipulation.},
    isbn        = {978-3-540-45350-5},
    doi			= {10.1007/3-540-45350-4_5}
}

@inproceedings{Chapman:2006:CCM:1151816.1151820,
    author      = {Chapman, Roderick},
    title       = {Correctness by Construction: A Manifesto for High Integrity Software},
    booktitle   = {Proceedings of the 10th Australian Workshop on Safety Critical Systems and Software - Volume 55},
    series      = {SCS '05},
    year        = {2006},
    isbn        = {1-920-68237-6},
    location    = {Sydney, Australia},
    pages       = {43--46},
    numpages    = {4},
    url         = {http://dl.acm.org/citation.cfm?id=1151816.1151820},
    acmid       = {1151820},
    publisher   = {Australian Computer Society, Inc.},
    address     = {Darlinghurst, Australia, Australia},
    keywords    = {SPARK, correctness-by-construction, safety-critical, security-critical, software engineering}
}

@inproceedings{685738,
    author      = {P. {Hudak}},
    booktitle   = {Proceedings. Fifth International Conference on Software Reuse (Cat. No.98TB100203)},
    title       = {Modular domain specific languages and tools},
    year        = {1998},
    volume      = {},
    number      = {},
    pages       = {134-142},
    keywords    = {functional languages;software tools;software reusability;program interpreters;modular domain specific languages;software tools;software maintenance;program understanding;methodology;domain specific embedded languages;higher-order typed programming language;Haskell;ML;modular interpreters;semantics;implementation code;software reuse;functional languages;syntax;Domain specific languages;DSL;Application software;Computer languages;Costs;Programming;Buildings;Hardware;Computer science;Software maintenance},
    doi         = {10.1109/ICSR.1998.685738},
    ISSN        = {1085-9098},
    month       = {June}
}

@article{hudak1996building,
    title       = {Building domain-specific embedded languages},
    author      = {Hudak, Paul and others},
    journal     = {ACM Comput. Surv.},
    volume      = {28},
    number      = {4es},
    pages       = {196},
    year        = {1996},
    publisher   = {Citeseer},
    doi         = {10.1.1.49.6020}
}


@misc{cisco-whitepaper,
	author		= {Dave Evans},
	title		= {The Internet of Things},
	howpublished = {\url{https://www.cisco.com/c/dam/en_us/about/ac79/docs/innov/IoT_IBSG_0411FINAL.pdf}},
	subtitle 	= {How the Next Evolution of the Internet Is Changing Everything},
	note 		= {[Online; Accessed March 2019]},
	organization = {Cisco},
	month 		= {April},
	year 		= {2011}
}

@report{teamplay:d1.1,
	author 		= {Chris Brown},
	title 		= {Report on Code-Level Contracts for Energy, Time and Security},
	type 		= {Deliverable},
	institution = {University of St Andrews},
	date 		= {1 January 2018},
	note 		= {[Online; Accessed Mar 2019]},
	url 		= {https://gitlab.inria.fr/TeamPlay_Public/TeamPlay_Public_Deliverables/blob/master/D1.1.pdf}
}

@article{brady_2013,
	title		= {Idris, a general-purpose dependently typed programming language: Design and implementation},
	volume		= {23},
	doi			= {10.1017/S095679681300018X},
	number		= {5},
	journal		= {Journal of Functional Programming},
	publisher	= {Cambridge University Press},
	author		= {Brady, Edwin},
	year		= {2013},
	pages		= {552–593}
}

@inproceedings{Lee:2008:FFC:1375657.1375670,
	author		= {Lee, Jaejin and Kim, Junghyun and Jang, Choonki and Kim, Seungkyun and Egger, Bernhard and Kim, Kwangsub and Han, SangYong},
	title 		= {FaCSim: A Fast and Cycle-accurate Architecture Simulator for Embedded Systems},
	booktitle 	= {Proceedings of the 2008 ACM SIGPLAN-SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems},
	series 		= {LCTES '08},
	year 		= {2008},
	isbn 		= {978-1-60558-104-0},
	location 	= {Tucson, AZ, USA},
	pages 		= {89--100},
	numpages 	= {12},
	url 		= {http://doi.acm.org/10.1145/1375657.1375670},
	doi 		= {10.1145/1375657.1375670},
	acmid 		= {1375670},
	publisher 	= {ACM},
	address 	= {New York, NY, USA},
	keywords 	= {architecture simulator, cycle-accurate simulation, full-system simulation, simulator parallelization, virtual prototyping}
}

@inproceedings{10.1007/3-540-46002-0_32,
	author		= {Amnell, Tobias and Fersman, Elena and Mokrushin, Leonid and Pettersson, Paul and Yi, Wang},
	editor		= {Katoen, Joost-Pieter and Stevens, Perdita},
	title		= {TIMES b--- A Tool for Modelling and Implementation of Embedded Systems},
	booktitle	= {Tools and Algorithms for the Construction and Analysis of Systems},
	year		= {2002},
	publisher	= {Springer Berlin Heidelberg},
	address		= {Berlin, Heidelberg},
	pages		= {460--464},
	abstract	= {Times is a modelling and schedulability analysis tool for embedded real-time systems, developed at Uppsala University in 2001. It is appropriate for systems that can be described as a set of preemptive or non-preemptive tasks which are triggered periodically or sporadically by time or external events. It provides a graphical interface for editing and simulation, and an engine for schedulability analysis. The main features of Times are:A graphical editor for timed automata extended with tasks [1], which allows the user to model a system and the abstract behaviour of its environment In addition the user may specify a set of preemptive or non-preemtive tasks with parameters such as (relative) deadline, execution time, priority, etc.A simulator, in which the user can validate the dynamic behaviour of the system and see how the tasks execute according to the task parameters and a given scheduling policy. The simulator shows a graphical representation of the generated trace showing the time points when the tasks are released, invoked, suspended, resumed, and completed.A verifier for schedulability analysis, which is used to check if all reachable states of the complete system are schedulable that is, all task instances meet their deadlines. A symbolic algorithm has been developed based on the DBM techniques and implemented based on the verifier of the Uppaal tool [2].A code generator for automatic synthesis of C-code on LegoOS platform from the model. If the automata model is schedulable according to the schedulability analyser the execution of the generated code will meet all the timing constraints specified in the model and the tasks.},
	isbn		= {978-3-540-46002-2},
	doi			= {10.1007/3-540-46002-0_32}
}

@inproceedings{782199,
	author		= {T. {Simunic} and L. {Benini} and G. {De Micheli}},
	booktitle	= {Proceedings 1999 Design Automation Conference (Cat. No. 99CH36361)},
	title		= {Cycle-accurate simulation of energy consumption in embedded systems},
	year		= {1999},
	volume		= {},
	number		= {},
	pages		= {867-872},
	keywords	= {embedded systems;instruction sets;digital simulation;low-power electronics;circuit CAD;circuit simulation;integrated circuit design;DC-DC power convertors;energy model;energy consumption;embedded systems;instruction-level cycle-accurate simulator;L2 cache;interconnect;DC-DC converter;SmartBadge;StrongARM-1100 processor;Dhrystone benchmark;simulation methodology;real-time MPEG feature;Energy consumption;Embedded system;Computational modeling;Prototypes;Hardware;DC-DC power converters;System-on-a-chip;Software prototyping;Power dissipation;Costs},
	doi			= {10.1109/DAC.1999.782199},
	ISSN		= {},
	month		= {June}
}

@article{howard1980formulae,
	title		= {The formulae-as-types notion of construction},
	author		= {Howard, William A},
	year		= {1980}
}

@inproceedings{10.1007/978-3-540-74130-5_9,
	author		= {Brady, Edwin},
	editor		= {Horv{\'a}th, Zolt{\'a}n and Zs{\'o}k, Vikt{\'o}ria and Butterfield, Andrew},
	title		= {Ivor, a Proof Engine},
	booktitle	= {Implementation and Application of Functional Languages},
	year		= {2007},
	publisher	= {Springer Berlin Heidelberg},
	address		= {Berlin, Heidelberg},
	pages		= {145--162},
	abstract	= {Dependent type theory has several practical applications in the fields of theorem proving, program verification and programming language design. Ivor is a Haskell library designed to allow easy extending and embedding of a type theory based theorem prover in a Haskell application. In this paper, I give an overview of the library and show how it can be used to embed theorem proving technology in an implementation of a simple functional programming language; by using type theory as a core representation, we can construct and evaluate terms and prove correctness properties of those terms within the same framework, ensuring consistency of the implementation and the theorem prover.},
	isbn		= {978-3-540-74130-5},
	doi			= {10.1007/978-3-540-74130-5_9}
}

@book{brady_2017,
    place       = {Shelter Island, NY},
    title       = {Type-Driven Development with Idris},
    publisher   = {Manning},
    author={Brady, Edwin},
    year        = {2017}
}

@article{board1996ariane,
    title       = {ARIANE 5 Flight 501 Failure, Report by the Inquiry Board},
    author      = {Board, Inquiry},
    journal     = {Paris, July},
    volume      = {19},
    year        = {1996}
}

@article{nasa2006dart,
    title       = {Overview of the DART mishap investigation results},
    author      = {Croomes, S},
    journal     = {NASA Report},
    pages       = {1--10},
    year        = {2006}
}

@article{borras2006overexposure,
    title       = {Overexposure of radiation therapy patients in Panama: problem recognition and follow-up measures},
    author      = {Borr{\'a}s, Cari},
    journal     = {Revista Panamericana de Salud P{\'u}blica},
    volume      = {20},
    pages       = {173--187},
    year        = {2006},
    publisher   = {SciELO Public Health}
}

@inproceedings{10.1007/978-3-642-22110-1_47,
    author      = {Kwiatkowska, Marta and Norman, Gethin and Parker, David},
    editor      = {Gopalakrishnan, Ganesh and Qadeer, Shaz},
    title       = {PRISM 4.0: Verification of Probabilistic Real-Time Systems},
    booktitle   = {Computer Aided Verification},
    year        = {2011},
    publisher   = {Springer Berlin Heidelberg},
    address     = {Berlin, Heidelberg},
    pages       = {585--591},
    abstract    = {This paper describes a major new release of the PRISM probabilistic model checker, adding, in particular, quantitative verification of (priced) probabilistic timed automata. These model systems exhibiting probabilistic, nondeterministic and real-time characteristics. In many application domains, all three aspects are essential; this includes, for example, embedded controllers in automotive or avionic systems, wireless communication protocols such as Bluetooth or Zigbee, and randomised security protocols. PRISM, which is open-source, also contains several new components that are of independent use. These include: an extensible toolkit for building, verifying and refining abstractions of probabilistic models; an explicit-state probabilistic model checking library; a discrete-event simulation engine for statistical model checking; support for generation of optimal adversaries/strategies; and a benchmark suite.},
    isbn        = {978-3-642-22110-1}
}

@article{Schlich2009,
    author      = {Schlich, Bastian and Kowalewski, Stefan},
    title       = {Model checking C source code for embedded systems},
    journal     = {International Journal on Software Tools for Technology Transfer},
    year        = {2009},
    month       = {Jul},
    volume      = {11},
    number      = {3},
    pages       = {187--202},
    abstract    = {In this paper, the applicability of model checking to C code for embedded systems is studied. The paper is divided into two parts. In the first part, 13 existing model checkers for C code are detailed and evaluated for their applicability in the verification of C code for embedded systems. A case study is presented that applied CBMC as one representative C code model checker to an exemplary microcontroller program. As a consequence of this case study, we decided to develop a new model checker for source code for microcontrollers, called  [mc]square. It is described in the second part of this paper. We present the architecture and the peculiarities of  [mc]square, and we successfully applied  [mc]square to the same microcontroller program used in the case study.},
    issn        = {1433-2787},
    doi         = {10.1007/s10009-009-0106-5},
    url         = {https://doi.org/10.1007/s10009-009-0106-5}
}

@article{Larsen1997,
    author      = {Larsen, Kim G. and Pettersson, Paul and Yi, Wang},
    title       = {Uppaal in a nutshell},
    journal     = {International Journal on Software Tools for Technology Transfer},
    year        = {1997},
    month       = {Dec},
    volume      = {1},
    number      = {1},
    pages       = {134--152},
    issn        = {1433-2779},
    doi         = {10.1007/s100090050010},
    url         = {https://doi.org/10.1007/s100090050010}
}

@inbook{Valmari1998,
    author      = {Valmari, Antti},
    editor      = {Reisig, Wolfgang and Rozenberg, Grzegorz},
    title       = {The state explosion problem},
    bookTitle   = {Lectures on Petri Nets I: Basic Models: Advances in Petri Nets},
    year        = {1998},
    publisher   = {Springer Berlin Heidelberg},
    address     = {Berlin, Heidelberg},
    pages       = {429--528},
    abstract    = {State space methods are one of the most important approaches to computer-aided analysis and verification of the behaviour of concurrent systems. In their basic form, they consist of enumerating and analysing the set of the states the system can ever reach. Unfortunately, the number of states of even a relatively small system is often far greater than can be handled in a realistic computer. The goal of this article is to analyse this state explosion problem from several perspectives. Many advanced state space methods alleviate the problem by using a subset or an abstraction of the set of states. Unfortunately, their use tends to restrict the set of analysis or verification questions that can be answered, making it impossible to discuss the methods without some taxonomy of the questions. Therefore, the article contains a lengthy discussion on alternative ways of stating analysis and verification questions, and algorithms for answering them. After that, many advanced state space methods are briefly described. The state explosion problem is investigated also from the computational complexity point of view.},
    isbn        = {978-3-540-49442-3},
    doi         = {10.1007/3-540-65306-6_21},
    url         = {https://doi.org/10.1007/3-540-65306-6_21}
}

@inbook{Clarke2001,
    author      = {Clarke, Edmund and Grumberg, Orna and Jha, Somesh and Lu, Yuan and Veith, Helmut},
    editor      = {Wilhelm, Reinhard},
    title       = {Progress on the State Explosion Problem in Model Checking},
    bookTitle   = {Informatics: 10 Years Back, 10 Years Ahead},
    year        = {2001},
    publisher   = {Springer Berlin Heidelberg},
    address     = {Berlin, Heidelberg},
    pages       = {176--194},
    abstract    = {Model checking is an automatic verification technique for finite state concurrent systems. In this approach to verification, temporal logic specifications are checked by an exhaustive search of the state space of the concurrent system. Since the size of the state space grows exponentially with the number of processes, model checking techniques based on explicit state enumeration can only handle relatively small examples. This phenomenon is commonly called the ``State Explosion Problem''. Over the past ten years considerable progress has been made on this problem by (1) representing the state space symbolically using BDDs and by (2) using abstraction to reduce the size of the state space that must be searched. As a result model checking has been used successfully to find extremely subtle errors in hardware controllers and communication protocols. In spite of these successes, however, additional research is needed to handle large designs of industrial complexity. This aim of this paper is to give a succinct survey of symbolic model checking and to introduce the reader to recent advances in abstraction.},
    isbn        = {978-3-540-44577-7},
    doi         = {10.1007/3-540-44577-3_12},
    url         = {https://doi.org/10.1007/3-540-44577-3_12}
}

@inbook{Clarke2012,
    author      = {Clarke, Edmund M. and Klieber, William and Nov{\'a}{\v{c}}ek, Milo{\v{s}} and Zuliani, Paolo},
    editor      = {Meyer, Bertrand
    and Nordio, M artin},
    title       = {Model Checking and the State Explosion Problem},
    bookTitle   = {Tools for Practical Software Verification: LASER, International Summer School 2011, Elba Island, Italy, Revised Tutorial Lectures},
    year        = {2012},
    publisher   = {Springer Berlin Heidelberg},
    address     = {Berlin, Heidelberg},
    pages       = {1--30},
    abstract    = {Model checking is an automatic verification technique for hardware and software systems that are finite state or have finite state abstractions. It has been used successfully to verify computer hardware, and it is beginning to be used to verify computer software as well. As the number of state variables in the system increases, the size of the system state space grows exponentially. This is called the ``state explosion problem''. Much of the research in model checking over the past 30 years has involved developing techniques for dealing with this problem. In these lecture notes, we will explain how the basic model checking algorithms work and describe some recent approaches to the state explosion problem, with an emphasis on Bounded Model Checking.},
    isbn        = {978-3-642-35746-6},
    doi         = {10.1007/978-3-642-35746-6_1},
    url         = {https://doi.org/10.1007/978-3-642-35746-6_1}
}

@inproceedings{10.1007/978-3-319-08434-3_9,
    author      = {Johansson, Moa and Ros{\'e}n, Dan and Smallbone, Nicholas and Claessen, Koen},
    editor      = {Watt, Stephen M. and Davenport, James H. and Sexton, Alan P. and Sojka, Petr and Urban, Josef},
    title       = {Hipster: Integrating Theory Exploration in a Proof Assistant},
    booktitle   = {Intelligent Computer Mathematics},
    year        = {2014},
    publisher   = {Springer International Publishing},
    address     = {Cham},
    pages       = {108--122},
    abstract    = {This paper describes Hipster, a system integrating theory exploration with the proof assistant Isabelle/HOL. Theory exploration is a technique for automatically discovering new interesting lemmas in a given theory development. Hipster can be used in two main modes. The first is exploratory mode, used for automatically generating basic lemmas about a given set of datatypes and functions in a new theory development. The second is proof mode, used in a particular proof attempt, trying to discover the missing lemmas which would allow the current goal to be proved. Hipster's proof mode complements and boosts existing proof automation techniques that rely on automatically selecting existing lemmas, by inventing new lemmas that need induction to be proved. We show example uses of both modes.},
    isbn        = {978-3-319-08434-3}
}

