\section{\texttt{Eq} operator}\label{app:evaln:ops:eq}
    \lstinputlisting[label={app:evaln:ops:eq-1-0}, caption={A C program which requires $1 = 0$}]{"../Idris_Stuff/Examples/Eq/Eq_1_0.c"}
    
    A correct C program asserting the vice-versa of the example in Section \ref{evaln:ops:eq}, Listing \ref{evaln:ops:eq-0-1}.
    
    \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_0.idr"}
    The resulting model `\texttt{eq\_1\_0}' consists of an assertion `\texttt{eq\_1\_0\_assert}' and nothing more. This assertion contains the literals 1 and 0 (assigned to \texttt{x} and \texttt{y} respectively), their evaluation (\texttt{x'} and \texttt{y'}), and a decidable proof of whether they are equal.
    \\
    
    \lstinputlisting[label={app:evaln:ops:eq-3-1}, caption={A C program which requires $3 = 1$}]{"../Idris_Stuff/Examples/Eq/Eq_3_1.c"}
    
    A valid C program which asserts that if we swap the operands of Listing \ref{evaln:ops:eq-1-3}, then the equality should not hold.
    
    \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_3_1.idr"}
    
    The resulting model has the literals swapped, but apart from that it is identical to the model for Listing \ref{evaln:ops:eq-1-3}.
    \\
    
    \begin{flushright}
        \textit{[to return to Eq: Section \ref{evaln:ops:eq}]}
    \end{flushright}

\newpage


\section{\texttt{NEq} operator}\label{app:evaln:ops:neq}
    \lstinputlisting[label={app:evaln:ops:neq-1-0}, caption={A C program which requires $1 \neq 0$}]{"../Idris_Stuff/Examples/NEq/NEq_1_0.c"}
    
    A syntactically correct C program asserting the same as Listing \ref{evaln:ops:neq-0-1} but with the operands swapped.
    
    \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_1_0.idr"}
    
    The resulting \Idris model. The literals 0 and 1 have been swapped compared to the model for Listing \ref{evaln:ops:neq-0-1}, but apart from that, the model is the same.
    \\
    
    \lstinputlisting[label={app:evaln:ops:neq-1-1}, caption={A C program which requires $1 \neq 1$}]{"../Idris_Stuff/Examples/NEq/NEq_1_1.c"}
    A valid C program that requires 1 to be not equal to 1, similar to Listing \ref{evaln:ops:neq-0-0} but with the immediate successor of 0.
    
    \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_1_1.idr"}
    The resulting model contains two literals, both carrying the value 1, their evaluation, and a decidable proof of whether they are not equal.
    \\
    
    \lstinputlisting[label={app:evaln:ops:neq-5-2}, caption={A C program which requires $5 \neq 2$}]{"../Idris_Stuff/Examples/NEq/NEq_5_2.c"}
    A correct C program which requires 5 to not be equal to 2, swapping the order of the operands from Listing \ref{evaln:ops:neq-2-5}.
    
    \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_5_2.idr"}
    The resulting \Idris model. The numbers 2 and 5 have swapped order compared to the model for Listing \ref{evaln:ops:neq-2-5}, to reflect the same swap made in the C program.
    \\
    
    \begin{flushright}
        \textit{[to return to NEq: Section \ref{evaln:ops:neq}]}
    \end{flushright}

\newpage


\section{\texttt{LTE} operator}\label{app:evaln:ops:lte}
    \lstinputlisting[label={app:evaln:ops:lte-0-1}, caption={A C program which requires $0 \leq 1$}]{"../Idris_Stuff/Examples/LTE/LTE_0_1.c"}
    
    This C program has the same structure as the one in Listing \ref{evaln:ops:lte-0-0}, this time asserting $0 \leq 1$.
    
    \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_0_1.idr"}
    
    Translating this to an \Idris model we get two literals carrying the values 0 and 1 respectively, their evaluation over a given environment, and a decidable proof of whether the first is less than or equal to the first.

    \lstinputlisting[label={app:evaln:ops:lte-3-3}, caption={A C program requiring $3 \leq 3$}]{"../Idris_Stuff/Examples/LTE/LTE_3_3.c"}
    
    \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_3_3.idr"}
    
    The corresponding \Idris model.
    \\
    
    \begin{flushright}
        \textit{[to return to LTE: Section \ref{evaln:ops:lte}]}
    \end{flushright}
    
    \newpage

\newpage


\section{\texttt{LT} operator}\label{app:evaln:ops:lt}
    \lstinputlisting[label={app:evaln:ops:lt-0-0}, caption={A C program which requires $0 < 0$}]{"../Idris_Stuff/Examples/LT/LT_0_0.c"}
    
    \idrisinput{"../Idris_Stuff/Examples/LT/LT_0_0.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, is derived from the successor of the left-hand side.
    
    \idrisinput{"../Idris_Stuff/Examples/LT/LT_0_0.out"}
    
    0 is not LT 0, since 1 cannot be LTE to 0.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:lt-0-1}, caption={A C program which requires $0 < 1$}]{"../Idris_Stuff/Examples/LT/LT_0_1.c"}
    
    \idrisinput{"../Idris_Stuff/Examples/LT/LT_0_1.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, is derived from the successor of the left-hand side.
    
    \idrisinput{"../Idris_Stuff/Examples/LT/LT_0_1.out"}
    
    1 is LTE to 1, so 0 is LT 1.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:lt-1-0}, caption={A C program which requires $1 < 0$}]{"../Idris_Stuff/Examples/LT/LT_1_0.c"}
    \idrisinput{"../Idris_Stuff/Examples/LT/LT_1_0.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, is derived from the successor of the left-hand side.
    
    \idrisinput{"../Idris_Stuff/Examples/LT/LT_1_0.out"}
    
    Since 2 cannot be LTE to 0, 1 cannot be LT 0.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:lt-1-3}, caption={A C program which requires $1 < 3$}]{"../Idris_Stuff/Examples/LT/LT_1_3.c"}
    
    \idrisinput{"../Idris_Stuff/Examples/LT/LT_1_3.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, is derived from the successor of the left-hand side.
    
    \idrisinput{"../Idris_Stuff/Examples/LT/LT_1_3.out"}
    
    Since 2 is LTE to 3, 1 is LT 3.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:lt-3-1}, caption={A C program which requires $3 < 1$}]{"../Idris_Stuff/Examples/LT/LT_3_1.c"}
    \idrisinput{"../Idris_Stuff/Examples/LT/LT_3_1.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, is derived from the successor of the left-hand side.
    
    \idrisinput{"../Idris_Stuff/Examples/LT/LT_3_1.out"}
    
    Since 4 cannot be LTE 1, 3 cannot be LT 1.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:lt-3-3}, caption={A C program which requires $3 < 3$}]{"../Idris_Stuff/Examples/LT/LT_3_3.c"}
    \idrisinput{"../Idris_Stuff/Examples/LT/LT_3_3.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, is derived from the successor of the left-hand side.
    
    \idrisinput{"../Idris_Stuff/Examples/LT/LT_3_3.out"}
    
    Since 4 cannot be LTE to 3, 3 cannot be LT 3.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage

\newpage


\section{\texttt{GTE} operator}\label{app:evaln:ops:gte}
    \lstinputlisting[label={app:evaln:ops:gte-0-0}, caption={A C program which requires $0 \geq 0$}]{"../Idris_Stuff/Examples/GTE/GTE_0_0.c"}
    \idrisinput{"../Idris_Stuff/Examples/GTE/GTE_0_0.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, has the arguments swapped compared to the order they appeared in.
    
    \idrisinput{"../Idris_Stuff/Examples/GTE/GTE_0_0.out"}
    
    Since 0 is LTE to 0, 0 is GTE to 0.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:gte-0-1}, caption={A C program which requires $0 \geq 1$}]{"../Idris_Stuff/Examples/GTE/GTE_0_1.c"}
    \idrisinput{"../Idris_Stuff/Examples/GTE/GTE_0_1.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, has the arguments swapped compared to the order they appeared in.
    
    \idrisinput{"../Idris_Stuff/Examples/GTE/GTE_0_1.out"}
    
    Since 1 cannot be LTE to 0, 0 cannot be GTE to 1.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:gte-1-0}, caption={A C program which requires $1 \geq 0$}]{"../Idris_Stuff/Examples/GTE/GTE_1_0.c"}
    \idrisinput{"../Idris_Stuff/Examples/GTE/GTE_1_0.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, has the arguments swapped compared to the order they appeared in.
    
    \idrisinput{"../Idris_Stuff/Examples/GTE/GTE_1_0.out"}
    
    Since 0 is LTE to 1, 1 is GTE to 0.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:gte-3-1}, caption={A C program which requires $3 \geq 1$}]{"../Idris_Stuff/Examples/GTE/GTE_3_1.c"}
    \idrisinput{"../Idris_Stuff/Examples/GTE/GTE_3_1.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, has the arguments swapped compared to the order they appeared in.
    
    \idrisinput{"../Idris_Stuff/Examples/GTE/GTE_3_1.out"}
    
    Since 1 is LTE to 3, 3 is GTE to 1.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:gte-1-3}, caption={A C program which requires $3 \geq 1$}]{"../Idris_Stuff/Examples/GTE/GTE_1_3.c"}
    \idrisinput{"../Idris_Stuff/Examples/GTE/GTE_1_3.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, has the arguments swapped compared to the order they appeared in.
    
    \idrisinput{"../Idris_Stuff/Examples/GTE/GTE_1_3.out"}
    
    Since 3 cannot be LTE to 1, 1 cannot be GTE to 3.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:gte-3-3}, caption={A C program which requires $3 \geq 3$}]{"../Idris_Stuff/Examples/GTE/GTE_3_3.c"}
    \idrisinput{"../Idris_Stuff/Examples/GTE/GTE_3_3.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, has the arguments swapped compared to the order they appeared in.
    
    \idrisinput{"../Idris_Stuff/Examples/GTE/GTE_3_3.out"}
    
    Since 3 is LTE to 3, 3 is GTE to 3.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}

\newpage


\section{\texttt{GT} operator}\label{app:evaln:ops:gt}
    \lstinputlisting[label={app:evaln:ops:gt-0-0}, caption={A C program which requires $0 > 0$}]{"../Idris_Stuff/Examples/GT/GT_0_0.c"}
    \idrisinput{"../Idris_Stuff/Examples/GT/GT_0_0.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, is derived from the successor of one of the arguments, and that it has the arguments swapped compared to the order they appeared in.
    
    \idrisinput{"../Idris_Stuff/Examples/GT/GT_0_0.out"}
    
    Since 1 cannot be LTE to 0, 0 cannot be GT 0.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:gt-1-0}, caption={A C program which requires $1 > 0$}]{"../Idris_Stuff/Examples/GT/GT_1_0.c"}
    \idrisinput{"../Idris_Stuff/Examples/GT/GT_1_0.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, is derived from the successor of one of the arguments, and that it has the arguments swapped compared to the order they appeared in.
    
    \idrisinput{"../Idris_Stuff/Examples/GT/GT_1_0.out"}
    
    Since 1 is LTE to 1, 1 is GT 0.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:gt-0-1}, caption={A C program which requires $0 > 1$}]{"../Idris_Stuff/Examples/GT/GT_0_1.c"}
    \idrisinput{"../Idris_Stuff/Examples/GT/GT_0_1.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, is derived from the successor of one of the arguments, and that it has the arguments swapped compared to the order they appeared in.
    
    \idrisinput{"../Idris_Stuff/Examples/GT/GT_0_1.out"}
    
    Since 2 cannot be LTE to 0, 0 cannot be GT 1.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:gt-3-1}, caption={A C program which requires $3 > 1$}]{"../Idris_Stuff/Examples/GT/GT_3_1.c"}
    \idrisinput{"../Idris_Stuff/Examples/GT/GT_3_1.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, is derived from the successor of one of the arguments, and that it has the arguments swapped compared to the order they appeared in.
    
    \idrisinput{"../Idris_Stuff/Examples/GT/GT_3_1.out"}
    
    Since 1 is LTE to 3, 3 is GT 1.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:gt-1-3}, caption={A C program which requires $1 > 3$}]{"../Idris_Stuff/Examples/GT/GT_1_3.c"}
    \idrisinput{"../Idris_Stuff/Examples/GT/GT_1_3.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, is derived from the successor of one of the arguments, and that it has the arguments swapped compared to the order they appeared in.
    
    \idrisinput{"../Idris_Stuff/Examples/GT/GT_1_3.out"}
    
    Since 3 cannot be LTE to 2, 1 cannot be GT 3.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}
    
    \newpage
    
    \lstinputlisting[label={app:evaln:ops:gt-3-3}, caption={A C program which requires $3 > 3$}]{"../Idris_Stuff/Examples/GT/GT_3_3.c"}
    \idrisinput{"../Idris_Stuff/Examples/GT/GT_3_3.idr"}
    
    The corresponding \Idris model. Note that the proof, \texttt{prf}, is derived from the successor of one of the arguments, and that it has the arguments swapped compared to the order they appeared in.
    
    \idrisinput{"../Idris_Stuff/Examples/GT/GT_3_3.out"}
    
    Since 4 cannot be LTE to 3, 3 cannot be GT 3.
    \\
    
    \begin{flushright}
        \textit{[to return to LT, GTE, and GT: Section \ref{evaln:ops:lt-gte-gt}]}
    \end{flushright}

\newpage


\section{\texttt{Or} operator}\label{app:evaln:ops:or}
    \lstinputlisting[label={app:evaln:ops:or-f-t}, caption={A C program where the right `or' operand happens to be true}]{"../Idris_Stuff/Examples/Or/Or_f_t.c"}
    
    The above C program has the same concept as Listing \ref{evaln:ops:or-t-f}, but with the \texttt{True} and \texttt{False} expression swapped.
    \\
    
    \begin{flushright}
        \textit{[to return to Or: Section \ref{evaln:ops:or}]}
    \end{flushright}
