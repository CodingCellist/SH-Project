\section{\texttt{Eq} operator}\label{app:evaln:ops:eq}
    \lstinputlisting{"../Idris_Stuff/Examples/Eq/Eq_1_0.c"}
    
    A correct C program asserting the vice-versa of the example in Section \ref{evaln:ops:eq}, Listing \ref{evaln:ops:eq-0-1}.
    
    \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_1_0.idr"}
    The resulting model `\texttt{eq\_1\_0}' consists of an assertion `\texttt{eq\_1\_0\_assert}' and nothing more. This assertion contains the literals 1 and 0 (assigned to \texttt{x} and \texttt{y} respectively), their evaluation (\texttt{x'} and \texttt{y'}), and a decidable proof of whether they are equal.
    \\
    
    \lstinputlisting{"../Idris_Stuff/Examples/Eq/Eq_3_1.c"}
    
    A valid C program which asserts that if we swap the operands of Listing \ref{evaln:ops:eq-1-3}, then the equality should not hold.
    
    \idrisinput{"../Idris_Stuff/Examples/Eq/Eq_3_1.idr"}
    
    The resulting model has the literals swapped, but apart from that it is identical to the model for Listing \ref{evaln:ops:eq-1-3}.
    
    
\section{\texttt{NEq} operator}\label{app:evaln:ops:neq}
    \lstinputlisting{"../Idris_Stuff/Examples/NEq/NEq_1_0.c"}
    
    A syntactically correct C program asserting the same as Listing \ref{evaln:ops:neq-0-1} but with the operands swapped.
    
    \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_1_0.idr"}
    
    The resulting \Idris model. The literals 0 and 1 have been swapped compared to the model for Listing \ref{evaln:ops:neq-0-1}, but apart from that, the model is the same.
    \\
    
    \lstinputlisting{"../Idris_Stuff/Examples/NEq/NEq_1_1.c"}
    A valid C program that requires 1 to be not equal to 1, similar to Listing \ref{evaln:ops:neq-0-0} but with the immediate successor of 0.
    
    \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_1_1.idr"}
    The resulting model contains two literals, both carrying the value 1, their evaluation, and a decidable proof of whether they are not equal.
    \\
    
    \lstinputlisting{"../Idris_Stuff/Examples/NEq/NEq_5_2.c"}
    A correct C program which requires 5 to not be equal to 2, swapping the order of the operands from Listing \ref{evaln:ops:neq-2-5}.
    
    \idrisinput{"../Idris_Stuff/Examples/NEq/NEq_5_2.idr"}
    The resulting \Idris model. The numbers 2 and 5 have swapped order compared to the model for Listing \ref{evaln:ops:neq-2-5}, to reflect the same swap made in the C program.


\section{\texttt{LTE} operator}\label{app:evaln:ops:lte}
    \lstinputlisting[label={evaln:ops:lte-0-1}, caption={A C program which requires $0 \leq 1$}]{"../Idris_Stuff/Examples/LTE/LTE_0_1.c"}
    
    This C program has the same structure as the one in Listing \ref{evaln:ops:lte-0-0}, this time asserting $0 \leq 1$.
    
    \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_0_1.idr"}
    
    Translating this to an \Idris model we get two literals carrying the values 0 and 1 respectively, their evaluation over a given environment, and a decidable proof of whether the first is less than or equal to the first.

    \lstinputlisting[label=app:evaln:ops:lte-3-3, caption={A C program requiring $3 \leq 3$}]{"../Idris_Stuff/Examples/LTE/LTE_3_3.c"}
    
    \idrisinput{"../Idris_Stuff/Examples/LTE/LTE_3_3.idr"}
